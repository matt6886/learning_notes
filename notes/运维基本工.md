# 运维基本工

## 运维概述和Linux系统安装

### 运维概述

**运维定义**

IT运维管理是指为了保证企业IT系统及网络的可用性，安全性，稳定性，保障业务的连续性，通过专业技术手段，对计算机网络，应用系统，电信网络，软硬件环境及运维服务流程等进行的综合管理。

**运维发展方向**

* 云计算

公有云（阿里云，腾讯云，百度云）

私有云

* DevOps

Development + Operation：开发+运维（4:6）

运营开发工程师

* AIOps
* CI/CD
* Docker容器化技术



### 操作系统

计算机组成：CPU，内存，硬盘，风扇，电源，声卡，网卡，显卡，鼠标键盘等。

计算机分为硬件资源和软件资源。

操作系统是硬件资源和软件资源之间沟通的桥梁。



## Linux基础命令

### 操作系统备份

养成系统备份的习惯，以便在需要的时候可以恢复系统。

系统备份分为：快照和克隆

**快照和克隆的区别**

快照是在同一台机器上，而克隆是在两台机器上，后期如果有危险操作，可以先快照的方式备份。



### Linux操作系统使用注意

**Linux是严格区分大小写的**

**Linux文件类型**

和Windows系统使用文件后缀扩展名来区分文件类型不一样，Linux通过 **权限位标识** 来确定文件类型。常见的文件类型有普通文件、目录、链接文件、块设备文件和字符设备等几种。Linux的可执行文件就是普通文件被赋予了可执行权限。

Linux的一些特殊文件是要求写扩展名的，但Linux不依赖扩展名来识别文件类型。

文件的扩展名主要有以下几类：

* 压缩包：*.gz, *.bz2, *.zip, *.tar.gz, *,tar.bz2, *.tgz等
* 二进制压缩包：CentOS使用的二进制安装包是RPM包，所有的RPM包都用 .rpm 扩展名结尾 
* 程序文件：Shell脚本一般使用 `.sh`扩展名结尾
* 网页文件：网页文件一般使用`.php`等结尾，不过这是网页服务器的要求，而不是Linux的要求

**LInux中一切皆是文件**

**Linux中存储设备必须挂在之后才可以使用**

分区+格式化+挂载

```bash
mount /dev/sda1 /mnt/file
```



### Linux的目录结构

在Linux的根目录（/），称为一级目录。

同时一级目录下包含许多的子目录，称为二级目录。

**Linux文件目录的用途**

| 一级目录    | 功能（作用）                                                 |
| ----------- | ------------------------------------------------------------ |
| /bin        | 存放系统命令，普通用户和root用户都可以执行。放在/bin目录下的命令在单用户模式下也可以执行。 |
| /boot       | 系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等。 |
| /dev        | 设备文件保存位置                                             |
| /etc        | 配置文件保存位置。系统内所有采用默认安装方式的服务配置文件全部保存在此目录中，如用户信息，服务的启动脚本，常用服务的配置文件等 |
| /home       | 普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录。所有用户的主目录是在/home目录下建立一个和用户名相同的目录。如用户matt的主目录就是/home/matt。 |
| /lib        | 系统调用的函数库保存的位置。                                 |
| /media      | 挂载目录。系统建议用来挂载媒体设备，如软盘和光驱。           |
| /mnt        | 挂载目录。早期Linux中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如u盘，移动硬盘和其他操作系统的分区。 |
| /misc       | 挂载目录。系统建议用来挂载NFS服务的共享目录。虽然系统准备了3个默认挂载目录：/mdeia， /mnt， /misc，但到底在哪个目录中挂载什么设备由系统管理员决定。 |
| /opt        | 第三方安装的软件的保存位置。这个目录是放置和安装其他软件的位置。手工安装的源码软件包都可以安装到这个目录。不过很多习惯还是安装在/usr/local目录下 |
| /root       | root的主目录。普通用户的主目录在/home下，root用户的主目录在/下。 |
| /sbin       | 保存与系统环境设置相关的命令。只有root可以使用这些命令进行系统环境设置，但也有些命令允许普通用户查看。 |
| /srv        | 服务数据目录。一些系统服务启动之后，可以在这个目录中保存需要的数据。 |
| /tmp        | 临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录不要保留重要数据，建议每次开机都把该目录清掉。 |
| /usr        | 系统程序目录。类似于windows系统下的program files             |
| /lost+found | 当系统意外崩溃或者意外关机时，产生的一些文件碎片会存在在这里。在系统启动的过程中，fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现。例如/lost+found就是分区的备份恢复目录，/boot/lost+found就是/boot的备份恢复目录。 |
| /proc       | 虚拟文件系统。该目录中的数据并不存在在硬盘上，而是保存在内存中，主要保存系统的内核，进程，外部设备状态和网络状态等。如/proc/cpuinfo是保存cpu信息的，/proc/devices是保存设备驱动列表的，/proc/filesystems是保存文件系统列表的，/proc/net是保存网络协议信息的。 |
| /sys        | 虚拟文件系统。和/proc目录相似，该目录中的数据保存在内存中，主要保存与内核相关的信息。 |
| /var        | 经常变化的文件目录。网页文件，数据文件，日志文件等。         |



### Linux入门级命令

Linux终端打开后光标左侧字符串的含义
```bash
matt@Ubuntu:$
```

- matt：当前用户名
- @：分隔符
- Ubuntu：Linux主机名称
- ～：当前用户所在位置
- $/#：身份标识符，$代表普通用户，#代表超级管理员

**Linux命令格式**

一个完整的命令格式如下：

> 命令名称 [选项] [参数]

```bash
tail -n 3 readme.txt
```

有些命令没有选项也没有参数

```bash
pwd
```

有些命令只有选项，没有参数

```bash
ls -l
```

**Linux命令补全**

在Linux终端输入命令的前面几个字母后，按下table健会自动补全，如果有多个命令满足条件，则会把所有这个开头的命令列出来。

Table健不仅可以补全命令，还可以补全文件名。

**切换用户**

> su - 用户名

```bash
su - root
```

* `-`表示切换用户的同时切换家目录。

**uname命令**

获取计算机系统的相关信息。

```bash
uname
# a表示all，代表显示所有信息, 获取全部的系统信息，包括主机名，类型，内核版本，发布时间，开源计划等。
uname -a
```

**ls命令**

list show：以平铺的形式显示当前目录下的文件信息

```bash
ls
# ls后面可以跟绝对路径和相对路径
ls /matt
# ls [选项] [路径]
# 选项说明
# -l： 代表以详细列表的形式显示当前或其他目录下的文件信息
# -h：代表以较高的可读性显示文件的大小，通常与-l一起使用
# -a：all，显示所有文件，包含隐藏文件
```

**pwd命令**

print working directory：打印当前目录

```bash
pwd
```

**cd命令**

change directory：切换目录，从一个目录切换到另一个目录

```bash
cd /matt/home
# 这两个命令都可以快速的切换到家目录
cd
cd ~
```

**clear命令**

主要功能：清屏

```bash
clear
```

**whoami**

获取当前用户的用户名。

```bash
whoami
```

**reboot命令**

立即重启计算机

```bash
reboot
```

**shutdown命令**

作用是立即关机或者延迟关机

立即关机

```bash
shtdown -h 0 
shutdown -h now
# 选项说明
# -h: halt缩写，代表关机
```

> 在Linux中，除了可以使用shutdonw命令关机外，还可以使用`halt -p`的命令

延迟关机

```bash
# 10分钟后关机
shutdown -h 10
# 取消关机
# 贯标一直闪烁的情况，直接按control + C
# 或者使用取消关机
shutdown -c
```

**type命令**

主要结合help命令一起使用，用户判断命令的类型（属于内部命令还是外部命令）

```bash
# type 命令
type pwd
# 输出 pwd is a shell builtin ，说明是内部命令, 否则为外部命令
```

**history命令**

主要功能：显示系统以前输入的前1000条信息。

```bash
history
```

**hostnamectl命令**

主要功能：设置计算机的主机名称（给计算机起个名字）。

```bash
# 获取计算机主机名称
hostname
hostnamectl
# 更改主机名称
# --transient         临时设置主机名称
# hostnamectl --transient set-hostname 主机名称
# 主机名称遵循FQDN协议：功能+公司域名, 比如：web.itcast.con
# --static            永久的设置主机名称，还可以通过修改/etc/hostname的配置来设置
# hostnamectl --static set-hostname 主机名称, 可以不写--static
# --pretty            灵活的主机名称(主机名称可以添加特殊字符)
# hostnamectl --pretty set-hostname "主机名称"
# 查看主机名称
hostnamectl --pretty
```



### Linux文件管理

**Linux文件命名规则**

除了/外都可以使用，但是尽量避免使用特殊字符。

* 由于Linux严格区分大小写，所以尽量使用小写字母。
* 如果必须对文件进行分割，可以使用下划线_进行分割。

文件名命名的长度不要超过255个字符，文件命名尽量见名知意。

在Linux操作系统中，文件系统是通过文件的权限位来区分的，文件后缀名是方便管理人员区分文件类型。



**文件管理命令**

1. 目录的创建

```bash
# mkdir 文件目录
mkdir /home/matt/itheima
# mkdir -p 文件目录：递归创建目录
mkdir -p /a/b/c
# mkdir 多个目录：会同时创建多个目录
mkdir a b c
```

2. 目录的删除

```bash
# rmdir 目录名称: 只能删除空目录
rmdir test
#rmdir -p 目录名称1/目录名称2 递归删除
rmdir -p a/b/c
# rmdir 目录1 目录2 同时删除多个空目录
rmdir a b c
```

3. 文件的创建

```bash
# touch 文件称
touch readme.txt
# 创建多个文件
touch 1.txt 2.txt
# 快速创建多个文件
touch {1..5}.txt
```

4. 文件的删除

```bash
# rm [选项] 文件或者文件目录
# 选项说明
# -r：针对文件夹， 代表递归删除，先把目录下的文件删除，然后再删除文件夹
# -f：强制删除，不提示
rm -rf test
```

5. 复制操作

```bash
# cp [选项] 源文件或者文件夹目录路径
# 选项说明
# -r：递归复制，主要针对文件夹
cp 1.txt /tmp

# 复制文件并重命名
# cp [选项] 源文件或者文件夹 目标路径/新文件或者文件夹的名称
cp readme.txt /tmp/new.txt

# 复制文件夹到指定目录
# cp -r 源文件夹名称 目标目录
cp -r b /tmp/b
# 查看文件夹本身
ls -d /tmp/b
```

6. 剪切操作

```bash
# mv 源文件或者文件夹 目录路径
mv readme.txt /tmp/
```

7. 重命名操作

```bash
# mv 源文件或者文件夹名称 新文件或者新文件夹的名称
mv b bb
mv 23.txt 123.txt
```

mv命令既可以剪切操作，也可以重命名操作。

8. 打包压缩和解压缩

* 打包：默认情况下，Linux的压缩概念一次只能压缩一个文件。针对多个文件或者文件夹无法直接压缩。所以需要提前对多个文件或者文件夹进行打包，这样才可以进行压缩操作。打包只是把多个文件或者文件夹放在一个文件中，但是并没有进行压缩，所以其大小还是原来所有文件的总和。
* 压缩：压缩也是一个文件或者目录的集合，且这个集合也被存在在一个文件中，但是它的不同之处在于，压缩文件所占用的空间比集合中所有文件的大小的总和要小得多。

```bash
# 打包
# tar [选项] 打包后的文件名称.tar 多个文件或者文件夹
# -c：create，
# -v：显示打包的过程
# -f：filename，指定打包的文件名，此参数是必须加的
# -u：update的缩写，更新打包文件中的文件
# -t：查看打包文件内容
# 打包多个文件
tar -cvf all.txt 1.txt 2.txt 3.txt 
# 打包文件夹
tar -cvf test.tar test
# tar -tf 打包后的文件名称： 查看打包的文件信息
tar -tf all.tar
# tar -uf 打包后的文件名称:  更新打包的文件信息，往打包后的文件更新或者追加内容
tar -uf all.tar 4.txt 

# 释放打包文件
tar -xf all.tar
```

* 打包并压缩

Linux下，常用的压缩工具有很多，比如gzip，zip，bzip2，xz等。

tar在打包的时候，是支持压缩的，gzip，bzip2，xz压缩工具都可以在tar打包文件中使用。

```bash
# tar [选项] 压缩后的压缩包名称 要压缩的文件或者文件夹
# 常见参数：
# -z：使用gzip工具把打包的文件压缩为.gz格式
# -j：使用bzip2压缩工具把打包后的文件压缩为.bz2格式
# -J：使用xz压缩工具把打包的文件压缩问.xz的格式 
# 压缩速度：gzip > bzip2 > xz
# 压缩率：gzip < bzip2 < xz(100M 90M 80)
tar -zcf all.tar.gz 1.txt 2.txt 3.txt 4.txt 
```

* 解压操作

解压的过程很简单，就是把之前压缩中的参数-c换位-x即可。

```bash
tar -zxf all.tar.gz
# 加上参数v可以查看解压的进度
ta r -zxvf all.tar.gz
tar -jxf all.tar.bz2
tar -Jxf all.tar.xz
```

9. zip压缩与解压缩

```bash
# zip [选项] 压缩后的文件名称.zip 文件或者文件夹
# 选项说明
# -r：递归压缩，主要针对的是文件夹
# zip格式在windows，Linux，OS系统都可以正常使用
# 压缩文件
zip all.zip 1.txt 2.txt 3.txt 4.txt
# 压缩文件夹
zip -r test.zip test

# 解压缩
# uzip 压缩包名称：解压到当前目录
unzip all.zip 
# unzip 压缩包名称 -d 指定路径： 把文件解压到指定的目录
unzip all.zip -d all
```



### Vim文件编辑器概述

**vi概述**

vi（visual editor）编辑器通常被称为vi，它是Linux和Unix系统中最基本的编辑器，类似于windows系统下的notepad（记事本）编辑器。

**vim**

vim（vi improved）是vi编辑器的加强版，比vi更容易使用。vi的命令几乎全部可以在vim上使用。

**vim编辑器的安装**

```bash
# CentOS
yum install vim
# Ubuntu
sudo apt install vim -y
```

**命令线路图**

1. 重复次数

在命令模式下，先输入数字，再输入一个命令，可以让该命令重复执行指定次数

2. 移动和选择（多练）

* vim之所以快，关键在于可以快速定位到关键的行
* 移动命令可以和编辑命令组合使用

3. 编辑操作

* 删除、复制、粘贴、替换、缩排

4. 撤销和重复
5. 查找替换
6. 编辑



**移动命令**

1. 上下左右

| 键   | 功能 |
| ---- | ---- |
| h    | 左   |
| j    | 下   |
| k    | 上   |
| l    | 右   |

2. 行内移动

| 命令 | 英文 | 功能                       |
| ---- | ---- | -------------------------- |
| w    | word | 向右移动一个单词           |
| b    | back | 向前移动一个单词           |
| 0    |      | 行首                       |
| ^    |      | 行首，第一个不是空白的位置 |
| $    |      | 行尾                       |

3. 行数移动

| 命令   | 英文 | 功能                 |
| ------ | ---- | -------------------- |
| gg     | go   | 文件顶部             |
| G      | go   | 文件末尾             |
| 数字gg | go   | 移动到数字对应的行数 |
| 数字G  | go   | 移动到数字对应的行数 |
| :数字  |      | 移动到数字对应的行数 |

4. 屏幕移动

| 命令        | 英文   | 功能     |
| ----------- | ------ | -------- |
| control + b | back   | 向上翻译 |
| control + f | forwar | 向下翻译 |
| H           | Head   | 屏幕顶部 |
| M           | Middle | 屏幕中间 |
| L           | Low    | 屏幕底部 |

**移动（程序）**

1. 段落移动

* vim使用空行来区分段落
* 在程序开始时，通常一段功能相关的代码会卸载一起--之前没有空行

| 命令 | 功能   |
| ---- | ------ |
| {    | 上一段 |
| }    | 下一段 |

2. 括号切换

在程序世界中，()、{}、[]使用频率较高，而且都是成对出现的

| 命令 | 功能             |
| ---- | ---------------- |
| %    | 括号匹配以及切换 |

3. 标记

* 在开发时，某一块代码可能需要稍后处理，例如编辑、查看

* 此时，先使用`m`增加一个标记，这样就可以在需要时快速的跳转回来或者执行其他的编辑操作。
* 标记名称可以是a～z或者A～Z中的任何一个字母
* 添加了标记的行被删除，添加的标记也会同时被删除
* 如果在其他行添加了相同名称的标记，之前添加的标记就会被自动替换掉

| 命令 | 英文 | 功能                                       |
| ---- | ---- | ------------------------------------------ |
| mx   | mark | 添加标记x，x是a～z或者A～Z中的任何一个字母 |
| 'x   |      | 直接定位到标记的x位置                      |



**vim编辑器的四种模式**

1. 命令模式

使用vim编辑器时，默认处于命令模式。在命令模式下，可以移动光标，可以通过快捷键对文件内容进行复制、粘贴和删除操作。

2. 编辑模式或者输入模式

在命令模式下，输入小写字母a或者i，就可以进入编辑模式，在该模式下可以对文件的内容进行编辑。

3. 末行模式

在命令模式下输入冒号：即可进入末行模式，可以在末行输入命令来对文件进行查找，替换，保存，退出等操作。

4. 可视化模式

可以做一些列选操作（通过方向键选择某些列的内容）

**vim的使用**

1. 文件的打开

```bash
vim readme.txt
```

如果文件存在，则打开文件，否则直接在内存中打开一个同名的文件。

2. 文件的保存

编辑后进入命令模式后，按下冒号：，并输入wq保存并退出。

3. 文件的退出

命令模式下，没有编辑过，则输入:q则直接退出，否则输入:q! 强制退出。

**命令模式下操作**

1. 移动光标到首行或者尾行。

命令模式下，连续按两下gg，则移动到首行；输入G则移动到尾行。

2. 翻屏操作

向上翻屏：control + b(before)

向下翻屏： control + f(forward)

向上翻半屏： control + u(up)

向下翻半屏： control + d(down)

3. 快速移动光标到指定行

命令模式下，先输入行号，然后输入G，则会跳转到指定的行号

4. 复制和粘贴

vim中提供了一个被复制文本的缓冲区

* 复制命令会将选择的内容保存在缓冲区
* 删除命令删除的内容会被保存在缓冲区
* 在需要的位置，可以使用粘贴命令将缓冲区的内容插入到光标指定的位置

| 命令          | 英文  | 功能                          |
| ------------- | ----- | ----------------------------- |
| y（移动命令） | copy  | 复制                          |
| yy            | copy  | 复制一行，可以使用nyy复制多行 |
| p/P           | paste | 粘贴                          |

* 复制当前行（光标所在那一行）

按键：yy

粘贴：在想要粘贴的地方按下p则粘贴到这行的下方，按下P则粘贴到该行上方。

* 从当前行复制指定的行数，如复制5行， 5yy

粘贴：在想要粘贴的地方按下p则粘贴到这行的下方，按下P则粘贴到该行上方。

5. 剪切与删除

删除文本

| 命令          | 文本   | 功能                              |
| ------------- | ------ | --------------------------------- |
| x             | cut    | 删除光标所在字符或者选中文本      |
| d（移动命令） | delete | 删除移动命令对应的内容            |
| dd            | delete | 删除光标所在的行，可以ndd复制多行 |
| D             | delete | 删除至行尾                        |

> 提示：如果使用可视模式已经选中了一段文本，那么无论使用x还是d都可以删除选中的文本

* 删除命令可以和移动命令连用，以下是常见的组合命令

```bash
* dw # 从光标位置删除到单词末尾
* d0 # 从光标位置删除到一行的起始位置
* d} # 从光标位置删除到段落结尾
* ndd # 从光标位置向下连续删除n行
* d代码G # 从光标所在行 删除到 指定代码行 之间的所有代码
* d'a # 从光标所在行 删除到标记a 之间的所有代码
```

在vim编辑器中，剪切与删除的操作都是dd

如果剪切了文件，但是没有使用p进行粘贴，则是删除操作

如果剪切了文件，并使用了p进行粘贴，则是剪切操作

*  剪切或者删除当前行

按下dd，然后输入p/P

* 剪切或者删除多行

按下数字dd，然后输入p/P，比如5dd，p

* 特殊用法

如果想要删除后，当前行变为空白，则在输入dd后在输入D

6. 撤销与恢复

撤销：u

恢复：control + r

7. 替换

| 命令 | 英文    | 功能                   | 模式     |
| ---- | ------- | ---------------------- | -------- |
| r    | replace | 替换当前字符           | 命令模式 |
| R    | replace | 替换当前行光标后的字符 | 替换模式 |

* R模式下进入替换模式，替换完成后，按下Esc键返回命令模式
* 替换命令的作用就是不用进入编辑模式，对文本进行轻量级的修改

8. 缩排与重复执行

| 命令 | 功能         |
| ---- | ------------ |
| >>   | 向右增加缩进 |
| <<   | 向左增加缩进 |
| .    | 重复上次命令 |

缩排命令在开发程序时，统一增加代码的缩进比较有用

* 一次性在选中代码前增加4个空格，就叫做增加缩进
* 一次性在选中代码前删除4个空格，就叫做减少缩进

在可视模式下，缩排命令只需要使用一个 > 或者 < 

9. 查找

* 常规查找

命令模式下，输入/，然后输入要查找的内容

```bash
/string
```

使用n/N向下或者向上在搜索结果中切换。

* 单词快速匹配（命令模式）

| 命令 | 功能                       |
| ---- | -------------------------- |
| *    | 向后查找当前光标匹配的单词 |
| #    | 向前查找当前光标匹配的单词 |

在开发中，通过单词快速匹配，可以快速看到这个单词在什么位置使用过



**末行模式下的操作**

在命令模式下输入冒号：，则进入末行模式，在末行模式下，可以保存、退出，查找与替换，显示行号，paste模式等等。

1. 保存与退出

:w ： 对当前文件进行保存

:q ：退出当前的文件。但是文件必须已经保存了。

:wq ： 保存并退出当前文件。

如果一个文件在编辑时没有名称，则可以使用:wq 文件名称,代表把整个编辑的文件保存到指定的文件名称中，并退出。

:q!： 强制退出文件不保存。

2. 查找与搜索

在命令模式下，输入/，进入末行模式。输入要搜索或者查找的关键词，回车。

如果有多个位置满足搜索条件，则可以使用n/N进行切换，n表示向下，N表示向上。底部显示`search hit TOP`表示到头了。

输入:noh则可以取消高亮显示。

3. 文件内容的替换

进入末行模式后，根据需求替换。

* 只替换光标所在这一行的第一个满足条件的结果

```bash
# 需要切换光标的指定的行
:s/要替换的关键词/替换后的关键词 + 回车
```

* 替换光标所在这一行，所有满足条件的结果（但是只能替换这一行）

```bash
:s/要替换的关键词/替换后的关键词/g 
```

* 针对整个文档的所有行进行替换，只替换每一行满足条件的第一个结果

```bash
:%s/要替换的关键词/替换后的关键词
```

* 针对整个文件中的所有关键词

```bash
:%s/要替换的关键词/替换后的关键词/g
```

* 选择范围内替换

选中要替换的文本范围，命令格式下输入

```bash
:s/旧文本/新文本/g
```

* 确认替换

```bash
:%s/就文本/新文本/gc
```

y:yes; n:no; a:all; q: quit; l:last 把光标移动到行首； ^E: 向下滚屏；^Y:向上滚屏



4. 显示行号

```bash
:set nu
```

5. 取消行号

```bash
:set nonu
```

6. set paste模式

在终端vim粘贴代码时，发现插入的代码会有多余的缩进，而且会逐渐累加。原因是终端把粘贴的文本存入键盘缓存中，vim会把这些内容当作用户的键盘输入来处理。导致遇到换行符的时候，如果vim开启了自动缩进，就会默认把上一行的缩进插入到下一行的开头，最终是代码变乱。

在粘贴之前，输入下面的命令开启paste模式。这样可以保证我们张贴的代码格式和原来保持一致。

```bash
:set paste
```

粘贴完毕后，输入下面的命令关闭paste模式

```bash
:set nopaste
```

**模式命令扩展**

末行命令主要是针对文件进行操作的：保存、退出i、保存与退出、搜索与替换、另存、新建、浏览文件。

| 命令      | 英文  | 功能                                         |
| --------- | ----- | -------------------------------------------- |
| :e .      | edit  | 会打开内置的文件浏览器，浏览当前目录下的文件 |
| :n 文件名 | new   | 新建文件                                     |
| :w 文件名 | write | 另存为，但是仍然编辑当前文件,并不会切换文件  |

**分配命令**

* 使用分配命令，可以同时查看和编辑多个文件

| 命令          | 英文           | 功能         |
| ------------- | -------------- | ------------ |
| :sp [文件名]  | split          | 横向增加分屏 |
| :vsp [文件名] | vertical split | 纵向增加分屏 |

1. 切换分屏窗口

> 分屏窗口都是基于 `control + w`这个快捷键的，对应的英文单词是window

| 命令 | 英文    | 功能                                        |
| ---- | ------- | ------------------------------------------- |
| w    | window  | 切换到下一个窗口                            |
| r    | reverse | 互换窗口                                    |
| c    | close   | 关闭当前窗口，但是不能关闭最后一个窗口      |
| q    | quit    | 退出当前窗口，如果是最后一个窗口，则退出vim |
| o    | other   | 关闭其他窗口                                |



**编辑模式**

| 命令 | 英文   | 功能                   | 常用   |
| ---- | ------ | ---------------------- | ------ |
| i    | insert | 在当前字符前插入文本   | 常用   |
| I    | insert | 在行首插入文本         | 较常用 |
| a    | append | 在当前字符后插入文本   | 常用   |
| A    | append | 在行末添加文本         | 较常用 |
| o    |        | 在当前行后面插入一空行 | 常用   |
| O    |        | 在当前行前面插入一空行 | 常用   |

编辑模式和数字的连用

命令模式下输入数字10，然后输入i进入编辑模式，输入*，按Esc退出编辑模式i，可以看到显示了10个\*



**可视化模式**

vim中提供了3种可视化模式，可以方便程序员选择选中文本的方式。

| 命令      | 模式       | 功能                               |
| --------- | ---------- | ---------------------------------- |
| v         | 可视模式   | 从光标位置开始按照正常模式选择文本 |
| V         | 可视行模式 | 选中光标经过的完整行               |
| control+v | 可视块模式 | 垂直方向选中文本                   |

* 可视模式下，可以和移动命令连用，例如：ggVG可以快速选择所有内容。



命令模式下按下v（可视）或者V（可视行），则进入可视化模式（visual）

1. 可视化模式下的复制操作

命令模式下按v，使用光标上下左右键选择要复制的内容，然后按下y，移动光标，停在要粘贴的位置，按p，则可以粘贴内容。

2. 为配置文件添加多行注释

* 命令模式下，按control + v进入可视块模式（列模式）
* 将光标定位到指定的行，通过上下键移动光标位置
* 输入大写的I，然后输入#
* 按两下ESC键，则刚才所有选中的行的前方都会输入#
* 保存并退出

3. 为配置文件删除多行注释

* 命令模式下，按control +v进入列模式
* 使用方向键选中要移除的行
* 按下d删除

**vim编辑器的使用功能**

1. 代码着色

* 定义后缀名为网页文件的代码文件

* 编写对应的php代码

在vim编辑器中可以通过`:syntax on` 或者`:syntax off`开启或者关闭代码着色功能。

2. 异常退出

vim编辑文件后，没有保存，比如直接关闭终端或者断电等情况。这个时候再次打开文件会打开一个交换文件`.文件名称.swp`。

可以通过输入`D`或者`rm .文件名.swp`方式删除。

3. 退出vim编辑器

```bash
:x
```

文件没有修改，按下:x则相当于:q操作，如果文件修改过，则相当于:wq操作。如果文件没有修改过，按下:x不会更新修改时间，但是如果是:wq，即使没有修改过，也会修改更新时间。

**打开文件时让光标定位到指定的行**

```bash
vim readme.txt +10
```







## Linux文件管理和用户管理

### 查看文件的内容

1. cat命令：正序输出文件内容

```bash
cat 文件称
```

* 合并多个文件内容

```bash
# cat 文件名1 文件名2 ... >  合并后的文件名称
cat hello.txt world.txt > helloworld.txt
```

2. tac命令：倒序输出文件内容

```bash
# tac 文件名
tac helloworld.txt
```

3. head命令

作用：查看文件的前n行，如果不指定n，则默认显示前10行。

```bash
# head [选项] 参数
# -n 表示显示前n行内容
head readme.txt 
head -5 readme.txt
```

4. tail命令

作用：查看一个文件的最后n行，如果不指定，则显示最后的10行。

```bash
# tail 文件名
# -n: 表示显示最后n行内容
tail readme.txt
tail -3 readme.txt 
# -f: 动态查看和一个文件的输出（主要用于查询文件日志的变化）
sudo tail -f /var/log/syslog
# control + c退出
```

5. more分屏显示文件内容

```bash
# more 文件名称
more readme.txt
```

more命令拥有一些交互功能，可以通过快捷键进行操作这个more的阅读器。

| 回车键 | 向下移动一行 |
| ------ | ------------ |
| d      | 向下移动半页 |
| 空格   | 向下移动一页 |
| b      | 向上移动一页 |
| q      | 退出more     |

注意：more命令在加载文件时并不是一点一点进行加载的，而是打开文件时就已经把文件的全部内容加载到内存了。如果打开文件太大，可能会出现卡顿。退出后之前的内容也会显示在终端屏幕上。

6. less分屏显示文件内容

> **特别注意：** less命令不是一次把文件加载到内存中，而是一点一点进行加载，相对而言，读取文件效率更高。退出后，文件内容不是显示在屏幕上。

```bash
# less 文件名称
less /var/log/syslog
```

| 回车键     | 向下移动一行                           |
| ---------- | -------------------------------------- |
| d          | 向下移动半页                           |
| 空格       | 向下移动一页                           |
| b          | 向上移动一页                           |
| 上下方向键 | 向上或者向下移动，less命令特有功能命令 |
| less -N    | 显示行号                               |
| /          | 搜索指定的字符串                       |
| q          | 退出less                               |



### 统计文件信息

**统计文件内容数量**

命令：wc（word count）

作用：用于统计文件内容信息（包含行数，单词数，字节数等）

语法：wc [选项] 参数

常见参数：

\-l: 表示lines，行数。（以回车符和换行符为标准）

\-w: 表示words，单词数。依照空格来判断单词数量。

\-c: 表示bytes，字节数。（空格，回车，换行）

这些选项可以单独使用，也可以一起使用

```bash
wc -lwc readme.txt 
# 输出 31  39 165 readme.txt
```



**du命令**

主要功能：查看文件或目录（会递归显示子目录）占用磁盘空间的大小。

```bash
# 基本用法
# du [选项] 统计的文件或者文件夹
# 选项说明
-s: summaries 只显示汇总的大小，统计文件夹的大小。
-h: 以较高的可读性显示文件或者文件夹的大小（KB/MB/GB/TB）
# 显示文件的大小
du readme.txt
du -h readme.txt
# 统计文件夹
du -h test # 会统计所有test文件夹下的所有文件夹的大小
du -sh test # 加上s后则只统计这个文件夹
```



### 文本处理

**find命令**

基本用法

```bash
# find 要搜索的路径 [选项]
-name: 指定要搜索的文件的名称，支持*星号通配符
-type：代表要搜索的文件类型，f表示普通文件，d表示文件夹
# 搜索文件
find ./test/ -name "*.txt" -type f
# 搜索文件夹
find / -name "ssh" -type d
# 输出 /etc/ssh ...
# 模糊搜索，使用*，*代表任意字符
find /var/log -name "*.log" -type f
```

主要功能：当我们要查找一个文件时，要使用的命令。返回要搜索的文件的具体路径。

**grep命令**

主要功能：在指定文件中找到包含指定关键词的行，并把这些内容高亮显示出来。

基本语法：

```bash
# grep [选项] 要搜索的关键词 搜索的文件名称
# -n：搜索包含关键的行，并且把行号显示出来
# 单位： 行
grep Note vboxpostinstall.sh 

grep Note -n vboxpostinstall.sh
# 搜索多个文件
# 在多个文件中查找指定关键词的行，并高亮显示
grep network /var/log/*
```

**echo命令**

主要功能：在终端中输出指定的文本内容

```bash
# echo 文本内容
echo "hello world"
```

**输出重定向**

场景：一般命令的输出都会显示在终端中，有些时候需要给一些命令的执行结果保存到文件中进行后续分析/统计，这个时候则需要使用到输出的重定向技术。

\>: 标准输出重定向：覆盖输出，会覆盖掉原先文件内容。

\>>: 追加重定向：追加输出，不会覆盖源文件的内容，会在原始文件内容的末尾继续添加。

```bash
# 覆盖输出
echo "hello world" > readme.txt
# 追加输出
echo "hello ssh" >> readme.txt 
```



### 用户和用户组

**了解用户和组**

服务器要添加多账户的作用，针对不同的用户添加不同的权限，不同的用户可以限制用户可以访问的系统资源，提高系统的安全性，帮助管理员对使用系统的用户进行管理。

**用户和组的关系**

理论上，Linux系统中每个用户在创建的时候都有一个对应的组，这个组称之为这个用户的主组。同时，某个用户需要临时需要使用某个组的权限，这个组称为这个用户的附属组或者附加组。主组只能有一个，附属组可能有多个。

**用户组操作**

用户组的操作包括用户组的添加、修改和删除操作。

组：group

添加：add

修改：mod

删除：del

1. 用户组的添加

基本语法

```bash
# groupadd [选项] 用户组的名称
# 选项说明
# -g：代表用户组的ID编号，自定义组必须从编号1000开始，不能重复
groupadd hr
groupadd -g 1100 matt2
```

默认情况下，我们添加的组都会放到一个系统文件中，文件位置：/etc/group

```bash
tail -3 /etc/group
# 输出：
# vboxdrmipc:x:983:
# hr:x:1001:
# matt2:x:1100:
# 有3个冒号，共4列
# 第1列：用户组名称
# 第2列：用户组密码，使用一 个x占位符
# 第3列：用户组ID 1-999 系统组 1000～ 自定义编号
# 第4列：用户组内的用户信息（如果一个用户的主组是这个组，不会显示在这里，只有用户的附属组是这个组，才会显示在这里, useradd -G 1000 wangwu）
useradd -G 1000 wangwu
```

2.  用户组的修改

基本用户

```bash
# groupmod [选项 选项值] 用户组名称
# 选项说明
# -g：gid缩写，设置一个自定义组的用户组ID数字，值在1000以后
# -n：name的缩写，设置用户组的名称
groupmod -n matt2 mattmod
groupmod -g 1002 mattmod
groupmod -g 1003 -n matt2 mattmod
```

3. 用户组的删除

基本用法:

```bash
# groupdel 用户组组名
groupdel matt2
```

**用户操作**

用户：user

添加：add

修改：mod

删除： del

1. 用户的添加

基本语法：

```bash
# useradd [选项 选项的值] 用户名称
# 选项说明
# -g：代表添加用户时指定用户所属组的主组，唯一的组信息（重要）
# -s: 代表用户可以使用的shell信息，默认为/bin/bash（拥有大部分权限）,还可以是/sbin/nologin，代表账号创建成功，但是用户不能登录操作系统 /bin/bash： 给运维工程师使用的，/sbin/nologin: 给软件使用的

# -G：代表添加用户所属组的附属组，可以添加多个，中间用逗号隔开（了解）
# -u：代表添加用户的ID编号，系统的1000以前，自定义的1000后（了解）
# -c：代表用户的备注信息 cqw: 123456
# -d：代表用户家目录，默认为：/home用户名称，可以使用-d进行更改
# -n：取消建立以用户名称为组的群组（了解）

# 没有指定用户的主组，这种情况下会创建和一个同名的用户组作为这个用户的主组，加-n则可以取消，
# 执行 tail -n 3 /etc/group 可以看到最后一行新增了一个名为 linuxuser 的用户组
# 这个创建的账号是不能登录Linux操作系统的，因为Linux系统的登录账号必须要有密码
useradd linuxuser
```

> 如果在创建用户的时候，没有指定用户的主组名称，依然可以创建用户，这种情况下，系统会创建一个和用户名称相同的组，作为这个用户的主组。

```bash
# 查询matt组的ID编号
grep matt /etc/group
# 输出：matt:x:1000:
# 创建用户zhangsan，主组为matt
useradd -g 1000 zhangsan
```

创建一个账号lisi，指定用户只能被软件使用，不能用于登录操作系统

```bash
useradd -g 1000 -s /sbin/nologin lisi
```

2. 用户信息查询

主要功能：查询某个指定用户的信息。

基本语法：

```bash
# id 用户名称
id linuxuser
# uid=1001(linuxuser) gid=1002(linuxuser) groups=1002(linuxuser)
# uid:用户编号
# gid：用户主组的ID
# groups：用户的主组以及附属组的信息，第一个时主组，后面的都是附属组或附加组信息
```

3. 与用户相关的文件

/etc/group；用户组的相关文件

/etc/passwd: 用户的相关文件

```bash
vim /etc/passwd
# matt:x:1000:1000:matt:/home/matt:/bin/bash
# 一种有7列
# 第1列：用户名称
# 第2列：用户密码，使用一个x占位，真实的密码放置在/etc/shadow中
# 第3列：用户的ID编号
# 第4列：用户主组的ID编号
# 第5列：代表注释信息 useradd -c "普通信息" 用户名称
# 第6列：用户的家目录，默认/home/用户名称
# 第7列：是用户使用的Shell类型，useradd -c /bin/bash
```

4. 用户的修改

基本语法：

```bash
# usermod [选项 选项的值] 用户名称
# 选项说明
# -g：修改用户主组的编号
# -l：login name 修改用户的名称
# -s：修改用户可以使用的shell类型

# -L: 锁定用户。锁定后，用户无法登录系统lock
# -U：解锁用户unlock

# -G：修改用户附属组的信息
# -d：修改用户的家目录
# -c：修改用户的附加信息

usermod -l zs zhangsan

usermod -g 1001 zs
 
usermod -s /sbin/nologin zs
```

```bash
# 锁定用户
usermod -L zs
# 解锁用户
usermod -U zs
```

> 解锁用户后依然无法登录原因
>
> * 用户没有设置密码,Linux不允许没有密码的用户的登录
> * 用户的shell为/sbin/nologin

5. passwd命令

主要作用：为某个用户添加或者设置密码

基本语法

```bash
# passwd 用户名称
# 给自己当前账号设置密码
passwd
# 给其他账户设置密码
passwd zs
```

> **特别注意：** 在Linux操作系统中，如果一个账号没有密码，则无法登录系统。
>
> root用户和普通用户修改密码有点区别：
>
> * root用户可以直接设置密码
> * 普通用户需要先输入之前的密码，然后才能重置密码

6. 补充知识

> Linux中除了可视化图形界面窗口，还有6个隐藏的字符窗口。Mac上可以使用control + option + Fn +  F3/F4(mac上需要同时按下fn + F3：比如 **fn+F3** = 真正的 F3， 登录后输入exit退出)
>
> control + option + F1可以i回到图形界面。

7. su命令

主要功能：切换用户的账号

基本语法：

```bash
# su [-] 要切换的用户名
# -: 代表切换用户的时候，同时切换用户的家目录
```

> 注意：
>
> 从超级管理员切换到普通用户，不需要输入密码；
>
> 从普通用户切换到普通用户或者超级管理员，都需要输入密码

* wheel组

只有wheel组中的普通用户才可以切换到root超级用户，默认所有用户都可以切换到超级管理员用户。只要知道root密码。换句话说，此配置默认不生效。

如果要开启这个配置：打开/etc/pam.d/su文件：`vim /etc/pam.d/su`, 去掉这行注释 `# auth    required  pam_wheel.so deny group=nosu`, 然后保存并退出。

8. 删除用户

基本语法
```bash
# userdel [选项] 用户名称
# 选项说明
# -r： 代表删除用户的同时，删除家目录。（默认不删除）
userdel zs

userdel -r wangwu
```

> 删除账号的流程：删除账号-> 确认是否删除用户的家目录-> 删除主组（没有其他账号）

当我们删除某个账号时，提示这个账号正在被某个进程使用，解决方案

方案1: 找到登录这个用户，然后将其注销

方案2: 简单粗暴，kill掉对应用户的全部进程

```bash
# kill [-9] 进程的ID编号
# 主要功能：用于结束某个进程的继续运行
# 9: 表示强制结束某个进程
kill -9 50651
# kill对应用户的全部进程(结束掉父进程，子进程会自动结束)
ps -ef | grep linuxuser
# 输出 root       54580   53904  0 07:57 pts/1    00:00:00 grep --color=auto linuxuser
# ps： 查看 进程
# -ef： 查看系统的所有进程
# grep linux： 搜索包含关键字的所有进程
```

> `ps -ef | grep linuxuser`遇到的坑
>
> 执行 `userdel -r linuxuser`提示`user linuxuser is currently used by process 54491`，但是执行 `ps -ef | grep linuxuser`却搜索不到这个进程。原因是第一列UID里面没有linuxuser字符，所以搜索不到。
>
> 直接使用`ps -u linuxuser`找到对应的PID，然后`kill -9 $PID`，之后再执行 `userdel -r linuxuser`就不会报这个错误了。



### 管道（重点）

**管道符**

"|", 竖线。

作用：管道是一种通信机制，通常用于进程间的通信。他表现出来的形式将前面一个进程的输出（stdout）作为后面一个进程的输入（stdin）。

![image-20250928172633020](/Users/matt/Desktop/Learning/learning_notes/notes/images/guandao.png)

0:标准输入，程序或者命令需要外部的某些程序传递相应的参数，才能正常运行。

1:标准输出，程序或者命令正确的执行结束，我们就称之为标准输出。

2:标准错误，程序或者命令错误的执行结果，我们就称为标准错误。

**过滤（筛选）功能**

基本语法

```bash
# 前一个命令 ｜ 后一个命令
# 获取根目录中包含y的文件信息
# grep的基本使用：grep 搜索的关键字 搜索的文件
ls / | grep y
# 查询系统中已经安装的软件中包含mariadb的软件
# CentOS
rpb -qa | grep mariabd # q: query a: all
# ubuntu
dpkg -l | grep mariadb
# 在系统进程中查看与matt相关的进程信息
ps -ef | grep matt
```

**特殊功能**

通过管道的操作方法来实现类似less的效果。

```bash
less /ver/log/syslog
# 等价于
cat /var/log/syslog | less
```

**统计功能**

```bash
# wc 命令
# -l: 统计总的行数
# -w：统计总的单词数
# -c：统计总的字节数
wc -lcw readme.txt
```

```bash
# 统计根目录下有多少个文件
ls / | wc -l
# 统计下目前系统有多少个用户
cat /etc/passwd | wc -l
```

**xargs命令**

之所以用到这个命令，关键是有许多命令不支持管道来传递参数，而日常工作中又有这个必要，所有就有了xargs命令。

> 简单来说，xargs命令就对管道命令进行了一个扩展，让所有命令都支持管道。

```bash
# 搜索/etc目录下所有以".conf“结尾的文件信息,
# 由于ls不支持管道命令，所以下面的这个命令不会得到你想要的结果
find /etc -name "*.conf" -type f | ls -l
```

解决方案，在ls命令之前添加一个xargs命令，这样ls就支持管道了，可以用于接受前一个命令的输出结果。

```bash
find /etc -name "*.conf" -type f | xargs ls -l
```



### 网络管理

**获取计算机的网络信息**

基本语法

```bash
# ifconfig
root@Ubuntu:/home/matt# ifconfig
enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.101.9  netmask 255.255.255.0  broadcast 192.168.101.255
        inet6 fe80::a00:27ff:fedd:2124  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:dd:21:24  txqueuelen 1000  (Ethernet)
        RX packets 1516062  bytes 1437725862 (1.4 GB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 284610  bytes 34197894 (34.1 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
# 解析 inet 192.168.101.9  netmask 255.255.255.0  broadcast 192.168.101.255
# inet 192.168.101.9：代表enp0s3网卡的ip地址，将来远程连接就是用的这个地址
# netmask 255.255.255.0：子网掩码，一般为255.255.255.0
# broadcast 192.168.101.255： 广播地址

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 1065  bytes 116246 (116.2 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1065  bytes 116246 (116.2 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        
# lo： 本地回环网卡，只有一个固定的地址，127.0.0.1代表本机
```

**与网卡相关的配置文件**

Linux系统中，一切皆为文件。所以保存网络信息也是通过一个文件来完成的。

```bash
# CentOS
# vim /etc/sysconfig/network-scripts/ifcfg-ens33
# Ubuntu
# ls /etc/netplan/
# 输出：01-network-manager-all.yaml  50-cloud-init.yaml
network:
  version: 2
  ethernets:
    enp0s3:
      dhcp4: true
# 网络解析
# network：表示整个网络的根结点，包含所有网络相关设置
# versioin：指定你的Netplan配置的版本号，2表示使用yaml格式
# ethernets：定义以太网的接口配置块。ethernets是Netplan支持的网络之一，用于配置有线网络接口，（其他类型包括wifis、bridges），它包含一个或多个接口的配置。
# enp0s3： 接口名称，具体取决于系统或硬件分配。enp0s3是虚拟机，这是你要配置的网络接口
# dhcp4: true： 指定是否启用IPV4 DHCP服务器获取IPV4地址，网管和DNS信息。如果设为 false，需手动指定 addresses:、gateway4: 和 nameservers: 等参数。
# 这段配置表示：使用 Netplan 版本 2，配置 enp0s3 接口，启用 DHCPv4，让系统自动获取 IPv4 网络设置（如 IP 地址、默认网关、DNS 服务器）。
```

**查询计算机网络状态**

基本语法

```bash
# CentOS
# systmctl status network

# Ubuntu
# systemctl status NetworkManager
NetworkManager.service - Network Manager
     Loaded: loaded (/usr/lib/systemd/system/NetworkManager.service; enabled; preset: enabled)
     Active: active (running) since Sat 2025-10-11 14:40:23 UTC; 2 days ago
       Docs: man:NetworkManager(8)
   Main PID: 904 (NetworkManager)
      Tasks: 4 (limit: 9434)
     Memory: 16.7M (peak: 32.6M)
        CPU: 27.478s
     CGroup: /system.slice/NetworkManager.service
             └─904 /usr/sbin/NetworkManager --no-daemon

# active（正常）或者inative（dead，网络不正常）
```

主要功能：查询计算机网络状态。

**启动/重启/停止网卡**

```bash
# CentOS
systemctl start network
systemctl restart network
systemctl stop network

# 解析
# start： 启动
# restart：重启
# stop：停止

# Ubuntu
systemctl stop NetworkManager
systemctl start NetworkManager
systemctl restart NetworkManager
```

### Linux远程连接与文件传输

**SSH协议**

SSH 协议（Secure Shell，安全外壳协议）是一种用于在不安全网络（如互联网）上进行安全远程登录和数据传输的网络协议。

SSH 是一种加密的网络协议，允许用户通过安全的通道访问远程计算机，执行命令、传输文件或管理服务器。

**sshd服务**

sshd 服务是 SSH 协议的服务器端实现，全称是 SSH Daemon（SSH 守护进程）。

定义：sshd 是一个后台运行的程序，监听 SSH 连接请求（默认 22 端口），允许远程用户通过 SSH 协议安全地登录和操作服务器。

作用：它是 SSH 客户端（如 ssh 命令）连接的目标端，负责处理认证、加密通信和命令执行。

默认情况下sshd服务是随计算机系统自动安装的。

```bash
systemctl status sshd
# 输出
ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/usr/lib/systemd/system/ssh.service; enabled; preset: enab>
     Active: active (running) since Tue 2025-09-23 01:00:42 UTC; 5 days ago
TriggeredBy: ● ssh.socket
       Docs: man:sshd(8)
             man:sshd_config(5)
   Main PID: 1311 (sshd)
      Tasks: 1 (limit: 9434)
     Memory: 4.2M (peak: 7.1M)
        CPU: 358ms
     CGroup: /system.slice/ssh.service
             └─1311 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"
```

SSH协议，其规定了远程连接与传输的端口号。所以计算机启动后，就会占用计算机的端口号22.

**常用SSH终端工具**

1. SecureCRT
2. XShell
3. Putty
4. MobaXterm



## Linux的权限管理

### 权限概述

**权限的概念**

在多用户系统的管理中，权限是指某个用户具有特定的系统资源使用权利。

Linux中分别有读、写和执行权限。

|       | 权限针对文件                                        | 权限针对文件夹                           |
| ----- | --------------------------------------------------- | ---------------------------------------- |
| 读r   | 表示可以查看文件内容：cat                           | 表示可以查看目录中存在的内容：ls         |
| 写w   | 表示可以更改文件内容                                | 表示可以删除文件夹中的文件或者新建子目录 |
| 执行x | 表示可以开启文件中记录的程序，一般指二进制文件：.sh | 表示是否可以进入目录中：cd               |

> 可读权限：read（r）， 可写权限：write（w）， 可执行权限：excute（x）

**Linux中用户身份类别**

1. user文件拥有者

文件的拥有者，谁创建的，谁拥有。但是文件的拥有者可以更改的。

2. group文件所属组内用户

group所属组内用户：代表与文件的所属组相同的组内用户。

3. other其他用户

既不是文件的拥有者，也不是文件所属组内的用户。

4. 特殊用户root

Linux系统中root账户拥有最高权限，权限设置对其无效。

> 三类用户的简写：user(u), group-(g), other(o)

### 普通权限管理

基本语法：

```bash
ls -l
# -rw-rw-r-- 1 matt matt   127 Sep 28 01:00 readme.txt
# drwxrwxr-x 6 matt matt  4096 Sep 27 03:47 test
# 解析：
# 第1列：文件类型+权限
# 第2列：文件的节点数
# 第3列：文件拥有者
# 第4列：文件所属组
# 第5列：文件大小
# 第6列：文件的更新时间
# 第6列：文件的名字
```

**文件类型+权限解析**

```bash
# -/rw-/rw-/r--
# 第1组为文件类型：
# 文件类型主要有3类，- 代表普通文件，d代表文件夹，l代表软连接（windows中的快捷方式）,b:block块设备文件（例如硬盘和光驱），p：管道文件，c：字符设备文件（例如猫（上网猫）等窜口设备，s：套接字文件/数据接口文件（例如启动一个mysql服务器时会产生一个mysql.sock文件）  
# 第2组为文件拥有者的权限
# 第3组为文件所属组内用户权限
# 第4组其他用户的权限
```

**文件或者文件夹权限设置（字母）**

基本语法：chmod=change mode

```bash
chmod [选项] 权限设置 文件或目录的名称
# 选项说明
# -R：递归设置，针对的是文件夹
# 增加权限
chmod u+x readme.txt
# 删除权限
chmod u-x readme.txt 
# 赋予权限
chmod g=rw readme.txt
# 对文件夹内所有文件所有用户都添加x权限
chmod -R a+x shop/
chmod -R ugo-x shop/

chmod -R u=rwx,g=r-x,o=r-x shop/
```

> 字母设置不难，需要考虑以下三方面：
>
> 第一点：确认给哪个身份设置权限，u，g，o， ugo(a)
>
> 第二点：确认是添加权限（+），删除权限（-），还是赋予权限（=）
>
> 第三点：确认给这个用户针对这个文件或者文件夹设置什么样的权限。r，w， x

**文件或者文件夹权限设置（数字）**

| 权限 | 对应数字 | 意义     |
| ---- | -------- | -------- |
| r    | 4        | 可读     |
| w    | 2        | 可写     |
| x    | 1        | 可执行   |
| -    | 0        | 没有权限 |

```bash
chmod 764 reademe.txt
# 第一个7:代表文件拥有者权限
# 第二个6:代表文件所属组内用户权限
# 第三个4：其他用户权限
chmod -R 777 shop/
```

> **注意：**在设置权限过程，单独设置2，3这种权限的是不合理的，一般不会这样设置，没有意义。

**特殊权限说明**

在Linux中，如果要删除一个文件，不是看文件有没有对应的权限，而是看文件所在**目录是否有写权限**，如果有才可以删除（同时必须具备执行权限）

**了解文件的拥有者和所属组来源**

在Linux操作系统中，每个文件都是由Linux系统用户创建的。在Linux操作系统中，每个用户都有一个用户名称以及主组的概念。

**文件拥有者设置**

基本语法：ch=change, own=owner

```bash
# chown: [选项] 新文件拥有者名称 文件名称
# 选项说明
# -R：代表递归修改，针对的文件夹
chown learn readme.txt
chown -R learn shop
```

**文件所属组设置**

基本语法：ch=change，group，grp

```bash
# chgrp [选项] 新文件所属组名称 文件名称
# 选项说明
# -R：代表递归修改，主要针对文件夹

chgrp wangwu readme.txt 
chgrp -R wangwu shop/
```

**chown同时修改属主和属组**

基本语法：

```bash
# chown [选项] 文件拥有者:文件所属组 文件名称
# 或者
# chown [选项] 文件拥有者.文件所属组 文件名称
# 选项
# -R：代表递归修改，主要针对文件夹
chown matt.matt readme.txt
chown learn:wangwu readme.txt
chown -R matt:matt shop/
```

### 特殊权限

**设置位s(SetUid)**

作用：为了让一般使用者临时具有该文件所属主/组的执行权限。

主要针对二进制文件（命令）。

例如：/usr/bin/passwd在执行的时候它回去修改/etc/passwd和/etc/shadow等文件，这些文件除了root外，其他用户都没有写权限。但是为了让普通用户可以修改自己的密码，该如何做呢？

> `whereis`命令：主要功能就是查询某个命令所在的路径。
>
> ```bash
> whereis passwd
> # 输出：passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1ssl.gz /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
> ```

```bash
ls -l /usr/bin/passwd
# -rwsr-xr-x 1 root root 64152 May 30  2024 /usr/bin/passwd
# 注意这里的s，它让普通用户可以临时拥有root权限，可以修改自己的密码。
```

**取消s位操作**

```bash
chmod u-s /usr/bin/passwd
# 或者
chmod 0755 /usr/bin/passwd
```

**添加s位权限**

```bash
chmod u+s /usr/bin/passwd
# 或者
chmod 4755 /usr/bin/passwd
```

**粘滞位T（sticky bit）**

针对的是文件夹。

主要功能：只允许文件的创建者和root用户可以i删除文件。（防止误删除权限位）

基本语法：
```bash
# chmod -R o+t 文件夹
# 或者
# chmod -R 1755 文件夹
ls -ld /tmp/
# drwxrwxrwt 17 root root 4096 Oct  1 07:38 /tmp/
# 注意这里t，只允许文件的创建者和root用户可以删除这个文件。
```

案例：/tmp文件夹，拥有最高权限777，比如用户a创建了一个文件在此目录，用户b也可以对这个文件进行删除操作，这种显然不太合适。

**移除粘滞位**

```bash
chmod -R o-t 文件夹
# 或者
chmod -R 0755 文件夹
```

### ACL访问控制

ACL（Access Control List）：访问控制列表，在Linux中，ACL可实现对单一用户设定访问文件的权限。

> ACL可以针对某个用户，也可以针对某个组。让权限控制更加精细。



**获取文件的ACL权限**

基本语法：

```bash
# getfacl 文件或目录名称
getfacl readme.txt 
```

> ```bash
> # 输出
> # file: readme.txt
> # owner: learn
> # group: wangwu
> user::rwx
> group::rwx
> other::r-x
> ```

**给某个文件设置ACL权限**

```bash
# setfacl [选项] 文件或目录名称
# 选项说明
# -m：修改acl策略
# -x：去掉某个用户或者组的权限
# -b：删除所有的alc策略

# -R：递归，通常用在文件夹

setfacl -m u:matt:r readme.txt
setfacl -m g:matt:rw readme.txt

setfacl -R -m g:wangwu:rw shop/

# 移除某个用户的acl权限
setfacl -x u:matt readme.txt
setfacl -x g:matt readme.txt 

# 移除文件或者文件夹所有的acl权限
setfacl -R -b shop/
```

### umask（了解）

umask表示创建文件时的默认权限（即创建文件时天生权限）

root用户下：`touch a`，文件的默认权限是644

普通用户下：`touch b`，文件b的默认权限是664

> 扩展：实际上我们创建一个普通文件最高权限666，而创建一个文件其最高权限777
>
> 实际文件权限=最高权限-umask的值

**获取用户的umask的值**

```bash
umask
# 0002 普通用户
# 0022 root用户
# root用户：666-022=644
# 普通用户：666-002=664
```

**修改mask值**

```bash
# 临时
umask 002
# 永久修改
# 家目录下.bashrc, 在文件夹默认添加 umask 002
```



## Linux自有服务和软件包管理

### 自有服务概述

服务是一些特定的进程，自有服务就是系统开机后就自动运行的一些进程，一旦客户端发出请求，这些进程就会自动为他们提供服务，windows系统中，把这些自动运行的进程，称为服务。

例如，当我们使用ssh客户端软件连接linux的时候，我们的服务器为什么会对连接做出响应？是因为ssh服务器开机就已经自动运行了。

所谓自有服务，简单来说，可以理解为Linux系统开机自动运行的服务（程序）。

### systemctl系统服务管理

**systemctl概述**

CentOS6版本：

service命令（管理服务开启，停止和重启）+ chkconfig（定义开机启动项）

```bash
# service network start|restart|stop
```

CentOS7版本

systemctl命令 = system系统+ control控制（服务管理+开机启动管理）

```bash
# system start|stop|restart network
```

**显示系统服务**

基本语法

```bash
# systemctl [选项]
# 选项说明
# list-units --type service --all: 列出所有服务（包含启动的和没有启动的）
# list-units --type servide: 列出所有启动的服务

# 列出Linux系统所有的服务
systemctl list-units --type service --all

# 列出Linux系统所有已经启动的服务
systemctl list-units --type service

# 将systemctl与grep结合使用
# CentOS
systemctl list-units --type service | grep network
systemctl list-units --type service | grep sshd

# Ubuntu
# 查看网络管理服务
systemctl list-units --type service | grep -i network

# 查看 SSH 服务
systemctl list-units --type service | grep ssh
```

**Linux系统服务管理**

1. 查看系统服务状态

```bash
# systemctl status 系统服务名称
```

查询系统服务中网络服务的状态

```bash
# CentOS7
systemctl status network
# Ubuntu
systemctl status NetworkManager
● NetworkManager.service - Network Manager
     Loaded: loaded (/usr/lib/systemd/system/NetworkManager.service; enabled; p>
     Active: active (running) since Sat 2025-09-27 08:58:33 UTC; 5 days ago
       Docs: man:NetworkManager(8)
   Main PID: 833 (NetworkManager)
      Tasks: 4 (limit: 9434)
     Memory: 15.8M (peak: 32.5M)
        CPU: 7.177s
     CGroup: /system.slice/NetworkManager.service
             └─833 /usr/sbin/NetworkManager --no-daemon

Warning: some journal files were not opened due to insufficient permissions.

# CentOS7
systemctl status sshd

# Ubuntu
systemctl status ssh
● ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/usr/lib/systemd/system/ssh.service; enabled; preset: enab>
     Active: active (running) since Wed 2025-10-01 01:43:14 UTC; 1 day 11h ago
TriggeredBy: ● ssh.socket
       Docs: man:sshd(8)
             man:sshd_config(5)
    Process: 1291 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
   Main PID: 1306 (sshd)
      Tasks: 1 (limit: 9434)
     Memory: 6.0M (peak: 6.8M)
        CPU: 138ms
     CGroup: /system.slice/ssh.service
             └─1306 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"

Warning: some journal files were not opened due to insufficient permissions.
```

2. stop停止服务

基本语法

```bash
# systemctl stop 服务名称
```

```bash
# CentOS7
systemctl stop network
# Ubuntu
systemctl stop NetworkManger
```

3. start开启服务

基本语法

```bash
systemctl start 服务名称
```

```bash
# CentOS
systemctl start network
# Ubuntu
systemctl start NetworkManger
```

4. restart重启服务

基本语法

```bash
systemctl restart 服务名称
```

```bash
# CentOS
systemctl restart network
# Ubuntu
systemctl restart NetworkManger
# 等价于 systemctl stop NetworkManger + systemctl start NetworkManger
```

5. reload热重载技术

```bash
systemctl reload 系统服务名称
```

reload: 重新加载指定服务的配置文件。（并非所有服务都支持reload，通常使用restart）。

> 有些服务，如Nginx，更改了配置文件，但是不能重启Nginx服务，只是想立即让我们配置好文件的更改生效，则就可以使用热重载技术了。

```bash
# CentOS7
systemctl reload crond
# Ubuntu 不支持reload cron
# sudo status cron
● cron.service - Regular background program processing daemon
     Loaded: loaded (/usr/lib/systemd/system/cron.service; enabled; preset: ena>
     Active: active (running) since Sat 2025-09-27 08:58:31 UTC; 5 days ago
       Docs: man:cron(8)
   Main PID: 751 (cron)
      Tasks: 1 (limit: 9434)
     Memory: 1.4M (peak: 3.5M)
        CPU: 1.782s
     CGroup: /system.slice/cron.service
             └─751 /usr/sbin/cron -f -P
```

6. 服务的持久化（开机自启和开机不自启）

所谓服务的持久化，就是服务在开机的时候，是否自动启动。

* 开机自启

```bash
# systemctl enable 系统服务名称

# CentOS7
system enable network

# Ubuntu
systemctl enable NetworkManager
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-unit-files ====
Authentication is required to manage system service or unit files.
Authenticating as: matt
Password: 
==== AUTHENTICATION COMPLETE ====
==== AUTHENTICATING FOR org.freedesktop.systemd1.reload-daemon ====
Authentication is required to reload the systemd state.
Authenticating as: matt
Password: 
==== AUTHENTICATION COMPLETE ====
```

* 开机不自启

```bash
# systemctl disable 系统服务名称
# CentOS7
systemctl disable network
# Ubuntu
systemctl disable NetworkManager
```

### 系统运行级别

运行级别全称（Running Level），代表Linux系统的不同运行模式。

**CentOS6运行级别**

```bash
# vim /etc/inittab
# 0: 系统关机状态 halt(Do NOT set initDefault to this)
init 0
# 1: 单用户工作状态 Single user mode(类似windows系统的安全模式，Linux忘记密码)
# 2: 多用户状态（没有NFS）：Multiuser，without NFS(The same as 3, if you do not have workiing)
# 3: 多用户状态（有NFS）： Full multiuser mode（字符模式，用的最多）
init 3
# 4: 系统未使用（留给用户）：unsued
# 5: 图形界面： X11（图形模式）
init 5
# 6: 系统正在关闭并重新启动： reboot(Do NOT set initDefault to this)
```

**CentOS7运行级别**

```bash
0 shutdown.target
1 emergency.target
2 resure.target
3 multiuser.target 字符模式
4 无
5 graphical.target 图形模式
6 无
# 查看当前默认模式
systemctl get-default 
```

**init命令（临时更改运行模式）**

```bash
# init 模式编号
```

**CentOS6中的chkconfig**

在CentOS7中，设置network开启启动，系统要求使用chkconfig命令

```bash
# chkconfig network on
```

设置完成后，如何查看network有没有开机自启动

```bash
chkconfig --list | grep network # 输出结果中3和5两种模式为on即可
```

### 常用自有服务（ntp，firewalld，crond）

| 服务名    | 含义                           |
| --------- | ------------------------------ |
| ntpd      | 用于同步计算机的系统时间的服务 |
| firewalld | 防火墙服务                     |
| crond     | 计划任务编号                   |

**NTP时间同步服务**

1. 什么是NTP服务

NTP是网络时间协议（Network Time Protocol），它是用来同步网络中各个计算机的时间的协议。

工作场景：

公司开发了一个电商网站，由于访问量很大，网络后端由100台服务器组成集群。50台服务器负责接受订单，50台服务器负责安排发货，接收订单的服务器需要记录下用户下单的具体时间，把数据传给负责发货的服务器，由于100台服务器的时间各不相同，记录的时间经常不一致，甚至会出现下单时间是明天，发货时间是昨天的情况。

2. NTP时间同步的原理

现在的标准时间是由原子钟报的国际标准时间UTC（Universal Time Coordinated，世界协调时），所以NTP获得的UTC时间来源可以是原子钟，天文台，卫星，也可以从Internet上获取。

在NTP中，定义了时间按照服务器的等级传播，startum层的总数限制在15以内，工作中，通常我们会使用各个组织提供的，现成的NTP服务器。

![image-20251009202514496](/Users/matt/Desktop/Learning/learning_notes/notes/images/ntp.png)

3. 从哪里找到合适的NTP服务器呢？

NTP授时网站：http://www.ntp.org.cn/pool

4. NTP时间同步操作

* 手工同步

基本语法

```bash
# ntpdate NTP服务器的IP地址或者域名
# 查看Linux系统时间
date
# 手动同步（需要先安装ntpdate）
ntpdate cn.ntp.org.cn
```

* 自动同步

基本语法

```bash
1. 启动ntp服务
systemctl start ntpd
2. 把ntpd追加到系统开机启动项中
systemctl enable ntpd

# 目前Ubuntu中使用的是系统自带的 systemd-timesyncd
sudo timedatectl set-ntp true
timedatectl status
# 输出中如果有：System clock synchronized: yes，就代表时间同步已启用。
```

**Linux中防火墙**

1. 什么是防火墙

防火墙：防范一些网络攻击，有软件防火墙，硬件防火墙之分。

>  防火墙选择让正常请求通过，从而保证网络的安全。

2. 防火墙的作用

![image-20251010210048446](/Users/matt/Desktop/Learning/learning_notes/notes/images/firewall01.png)

3. Linux中的防火墙分类

CentOS5、CentOS6中的防火墙：iptables防火墙

CentOS7：firewalld防火墙（fire：火，wall：墙，d：daemon（守护进程））

| **功能**       | **CentOS / RHEL**                            | **Ubuntu / Debian**               |
| -------------- | -------------------------------------------- | --------------------------------- |
| 防火墙管理服务 | **firewalld**                                | **ufw（Uncomplicated Firewall）** |
| 底层防火墙引擎 | iptables / nftables                          | iptables / nftables               |
| 配置文件位置   | /etc/firewalld/                              | /etc/ufw/                         |
| 服务启动命令   | systemctl start firewalld                    | ufw enable                        |
| 查看状态       | firewall-cmd --state                         | ufw status                        |
| 添加端口规则   | firewall-cmd --add-port=8080/tcp --permanent | ufw allow 8080/tcp                |
| 重新加载配置   | firewall-cmd --reload                        | ufw reload                        |

4. firewalld防火墙

firewalld增加了区域（zone）的概念，所谓区域是指，firewalld预先准备了几套防火墙策略的集合。类似于策略的模板，用户可以根据需求选择区域。

| 区域     | 默认策略                                                     |
| -------- | ------------------------------------------------------------ |
| trusted  | 允许所有数据包                                               |
| home     | 拒绝流入的流量，除非与流出的流量相关，允许ssh，mdns，ippclinet，amba-client，dhcpv6-client服务通过 |
| internal | 等同于home                                                   |
| work     | 拒绝流入的流量，除非与流出的流量相关，允许ssh，inet，dhcpv6-client服务通过 |
| public   | 拒绝流入的流量，除非与流出的流量相关，允许ssh，dhcpv6-client服务通过 |
| external | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |
| dmz      | 拒绝流入的流量，除非与流出的流量相关，允许ssh服务通过        |
| block    | 拒绝流入的流量，除非与流出的流量相关，非法流量采取拒绝的操作 |
| drop     | 拒绝流入的流量，除非与流出的流量相关，非法流量采取丢弃的操作 |

在Linux系统中，安装httpd服务，占用80端口

```bash
# CentOS
dnf install httpd -y
systemctl start httpd

# Ubuntu
apt install apache2
systemctl start apache2
```

| **功能**     | **CentOS**             | **Ubuntu**               |
| ------------ | ---------------------- | ------------------------ |
| 安装 Apache  | dnf install httpd      | apt install apache2      |
| 启动服务     | systemctl start httpd  | systemctl start apache2  |
| 查看状态     | systemctl status httpd | systemctl status apache2 |
| 设置开机自启 | systemctl enable httpd | systemctl enable apache2 |

在safari浏览器打开http://192.168.101.10发现在ufw关闭情况下可以正常访问，但是打开后就无法访问了。因为目前情况防护墙是不允许80端口通过防火墙的，所有开启防火墙后无法访问了。

```bash
ufw status
ufw enable
```

其实 **httpd** 和 **apache2** 指的是同一个东西 ——

它们都是 **Apache HTTP Server**（简称 Apache）的守护进程（daemon）。

| **名称**               | **全称 / 含义**                   | **说明**                                                |
| ---------------------- | --------------------------------- | ------------------------------------------------------- |
| **Apache HTTP Server** | 世界上最流行的 Web 服务器软件之一 | 用来提供网页服务（HTTP 服务）                           |
| **httpd**              | HTTP Daemon（HTTP 守护进程）      | Apache 在 **CentOS / RedHat / Amazon Linux** 中的服务名 |
| **apache2**            | Apache 2.x 版本的服务名           | Apache 在 **Ubuntu / Debian** 系列中的服务名            |

- httpd = Apache 服务（在 RHEL 系系统）
- apache2 = Apache 服务（在 Debian 系系统）

运行模式和永久模式：

运行模式：在此模式下，配置的防火墙策略立即生效，但是不写入配置文件

永久模式：此模式下，配置的防火墙策略写入配置文件中，但是需要reload重新加载才能生效。

firewalld默认采用的运行模式。

5. 防火墙的设置

* 防火墙的启动，停止和查看状态

查看运行状态

```bash
# CentOS
systemctl status firewalled
# Ubuntu
systemctl status ufw
 ufw.service - Uncomplicated firewall
     Loaded: loaded (/usr/lib/systemd/system/ufw.service; enabled; preset: enabled)
     Active: active (exited) since Fri 2025-10-10 13:43:20 UTC; 12h ago
       Docs: man:ufw(8)
   Main PID: 382 (code=exited, status=0/SUCCESS)
        CPU: 16ms

Oct 10 13:43:20 Ubuntu systemd[1]: Starting ufw.service - Uncomplicated firewall...
Oct 10 13:43:20 Ubuntu systemd[1]: Finished ufw.service - Uncomplicated firewall.
```

停止防火墙

```bash
# CentOS
systemctl stop firewalld
# Ubuntu
systemctl stop ufw
# 查看状态也可以使用
ufw status
```

> 防火墙一旦停止，设置的所有规则都将失效。

启动防火墙

```bash
# CentOS
systemctl start firewalld
# Ubuntu
systemctl start ufw
```

* 防火墙的重启和重载操作

防火墙的重启

```bash
# CentOS
systemctl restart firewalld
# Ubuntu
systemctl restart ufw
```

> restart = stop + start, 重启首先停止服务，然后再重新启动服务

防火墙的重载

```bash
# CentOS
systemctl reload firewalld

# Ubuntu
systmectl reload ufw
```

> 我们对防火墙的配置文件做了更改（永久模式），需要使用reload进行重载让其立即生效。
>
> reload没有停止正在运行的防火墙服务，只是在运行的基础上更换了防火墙的规则。

* 把防火墙设置为开机启动火开机不启动

开机启动

```bash
# CentOS
systemctl enable firewalld

# Ubuntu
systmectl enable ufw
```

开机不启动

```bash
# CentOS
systemctl disable firewalld

# Ubuntu
systmectl disable ufw
```

6. 防火墙规则

firewalld管理工具

```bash
# firewall-cmd [选项1] [选项2] [..M]
```

查看防火墙默认区域

```bash
firewalld-cmd --get-default-zone
```

| **CentOS / RHEL 命令（firewalld）**        | **Ubuntu 对应方式（ufw）**                   |
| ------------------------------------------ | -------------------------------------------- |
| firewall-cmd --get-default-zone            | **UFW 没有“zone”概念**，所以没有直接对应命令 |
| firewall-cmd --state                       | sudo ufw status                              |
| firewall-cmd --list-all                    | sudo ufw status verbose                      |
| firewall-cmd --add-port=80/tcp --permanent | sudo ufw allow 80/tcp                        |
| firewall-cmd --reload                      | sudo ufw reload                              |

查看所有支持的区域

```bash
firewalld-cmd --get-zones
```

查看当前区域的规则设置

```bash
# CentOS
firewalld-cmd --list-all

# Ubuntuv
sudo ufw status verbose
Status: active
Logging: on (low)
Default: deny (incoming), allow (outgoing), disabled (routed)
New profiles: skip

To                         Action      From
--                         ------      ----
22/tcp (OpenSSH)           ALLOW IN    Anywhere                  
80/tcp                     ALLOW IN    Anywhere                  
22/tcp (OpenSSH (v6))      ALLOW IN    Anywhere (v6)             
80/tcp (v6)                ALLOW IN    Anywhere (v6)  
```

查看所有区域的规则

```bash
firewalld-cmd --list-all-zones
```

7. 添加允许通过的服务或者规则（重点）

| **Firewalld 命令**                             | **Ubuntu (UFW) 对应命令**  | **说明**             |
| ---------------------------------------------- | -------------------------- | -------------------- |
| firewall-cmd --zone=public --add-service=http  | sudo ufw allow http        | 开放 HTTP (80端口)   |
| firewall-cmd --zone=public --add-service=https | sudo ufw allow https       | 开放 HTTPS (443端口) |
| firewall-cmd --add-port=8080/tcp               | sudo ufw allow 8080/tcp    | 开放自定义端口       |
| firewall-cmd --remove-service=http             | sudo ufw delete allow http | 删除规则             |
| firewall-cmd --reload                          | sudo ufw reload            | 重新加载规则         |
| firewall-cmd --list-all                        | sudo ufw status verbose    | 查看所有规则         |

* 通过服务的名称添加规则

```bash
# firewalld-cmd --zone=public --add-service=服务的名称
备注：服务必须存储在/usr/bin/firewalld/service目录中 
firewalld-cmd --zone=public --add-service=http

Ubuntu 默认使用的是 UFW（Uncomplicated Firewall），
而 UFW 并没有像 firewalld 一样的「service XML 配置目录」。

但它也有一组“应用配置文件”，存放在：
/etc/ufw/applications.d/

# 查看当前有哪些服务
sudo ufw app list
Available applications:
  Apache
  Apache Full
  Apache Secure
  CUPS
  OpenSSH
  
ufw allow Apache
Rule added
Rule added (v6)

ufw allow OpenSSH
Rule added
Rule added (v6)
```

> 如果你想让它永久生效（UFW 默认即永久）与 firewalld 不同，UFW **所有规则默认都是持久的**，所以你不需要加 --permanent 参数。

* 通过服务的端口号添加规则

```bash
# firewall-cmd --zone=public --add-port=服务的端口号

# 把80/tcp添加到防火墙规则中，允许通过防火墙
firewall-cmd --zone=public --add-port=80/tcp

# Ubuntu
ufw allow 80/tcp
```

8. 移除已经添加到防火墙的服务或者端口

扩展：把http服务从防火墙规则中移除，不允许其通过防火墙

```bash
# CentOS
firewall-cmd --zone=public --remove-service=http
# 查看
firewall-cmd --list-all

# Ubuntu
ufw delete allow Apache
Rule deleted
Rule deleted (v6)
```

9. 永久模式

Linux系统中，firewalld防火墙有两种模式：运行模式（临时模式）和永久模式。

运行模式：不会把规则保存到防火墙的配置文件中，但是会立即生效。

永久模式：会把规则保存到防火墙的配置文件中，但是不会立即生效。需要reload才会生效。

```bash
# 通过服务名称添加规则
firewall-cmd --zone=public --add-service=http --permanent
systemctl reload firewalld

# 根据端口号添加永久规则
firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --reload
```

**Linux中的计划任务**

1. 什么是计划任务

操作系统不可能一天24小时都有人在操作，有些时候需要在指定的时间去执行任务（例如，每天凌晨2点去重启http（Apache）服务），此时不可能真的有人每天2点去执行命令，这就可以交给计划任务程序去执行了。

> 在指定的时间去执行指定的任务。

2. Windows中的计划任务

控制面板-计划任务程序

3. Linux中计划任务

基本语法

```bash
# crontab [选项]
-l: list,显示目前已经设置的计划任务
-e: edit,使用vim编辑计划任务的文件
```

案例：显示当前账号下的计划任务

```bash
crontab -l
no crontab for root
```

案例：编写计划任务

```bash
crontab -e
# Ubuntu中，会提示选择哪个编辑器进行编辑
no crontab for root - using an empty one

Select an editor.  To change later, run 'select-editor'.
  1. /bin/nano        <---- easiest
  2. /usr/bin/vim.basic
  3. /usr/bin/vim.tiny
  4. /bin/ed

Choose 1-4 [1]: 2 
```

4. 计划任务的编辑

打开计划任务编辑文件后，可以在此文件中编辑我们自定义的计划任务。

计划任务的规则语法格式，以行为单位，一行则为一个计划。

```bash
分 时 日 月 周 要执行的命令（要求必须使用命令的完整路径，可以使用whereis或者which查看）

取值范围（常识）
分：0-59
时：0-23
日：1-31
月：1-12
周：0-7，0和7表示星期天

四个符号：
*：表示取值范围中的每一个数字
-：做连续区间表达式的，要想表示1～7，则可以写成1-7
/：表示每多少个，想每10分钟一次，则可以在分的位置写：*/10
,：表示多个取值，比如想在1点，2点和6点执行，则可以在时的位置些1,2,6
```

5. 案例

问题1:每月的1，10，23日的4:45重启network服务

```bash
第一步：
分 时 日     月 周 /usr/bin/systemctl restart network
第二步：
45 4 1,10,23 * * /usr/bin/systemctl restart network
```

问题2:每周六，周日的1:10重启network服务

```bash
10 1 * * 7,6 /usr/bin/systemctl restart network
```

问题3:每天18:00-23:00之间每间隔30分钟重启network服务

```bash
*/30 18-23 * * * /usr/bin/systemctl restart network
```

问题4:每隔2天上午的8点到11点的第3和第15分钟执行一次重启

```bash
3,15 8-11 */2 * * * /usr/sbin/reboot
```

案例5:每1分钟往root家目录中的readme.txt中输出一个1，为了看到效果使用追加输出，输出使用echo命令，echo 输出的内容

```bash
* * * * * /usr/bin/echo 1 >> /home/matt/readme.txt
```

可以使用 `tail -f readme.txt`查看

6. 计划任务权限问题

* 计划任务权限

crontab时任何用户都可以创建的任务，但是超级管理员可以通过配置设置哪些用户不允许计划任务。

可以通过配置黑名单来实现。

```bash
# ContOS
/etc/cron.deny

# Ubuntu
/etc/cron.deny

echo learn >> /etc/cron.deny
root@Ubuntu:/home/matt# cat /etc/cron.deny
learn
root@Ubuntu:/home/matt# su learn
$ crontab -e
You (learn) are not allowed to use this program (crontab)
See crontab(1) for more information
```

> 注意：默认这两个文件cron.deny和cron.allow默认是不存在的，需要手动创建。

白名单用于设置哪些用户可以使用我们的计划任务。`/etc/cron.allow`

```bash
echo learn >> /etc/cron.allow
root@Ubuntu:/home/matt# su learn
$ crontab -e
touch: cannot touch '/home/learn/.selected_editor': No such file or directory
Unable to create directory /home/learn/.local/share/nano/: No such file or directory
It is required for saving/loading search history or cursor positions.

No modification made
```

> 注意：白名单的优先级高于黑名单的优先级，如果一个用户通知在白名单和黑名单中，以白名单为准。

7. 查看计划任务的保存文件

```bash
# CentOS
ls /var/spool/cron
# Ubuntu
ls /var/spool/cron/crontabs/
learn  root
```

8. 计划任务的日志程序

问题：实际应用中，如何查看计划任务的运行情况？

通过计划任务日志，日志文件位于`/var/log/cron`

```bash
# CentOS
tail -f /var/log/cron

# Ubuntu
journalctl -u cron -f
```

> 在 Ubuntu（或其他使用 **systemd** 的 Linux 发行版）中用于**实时查看 cron 服务的日志输出**。
>
> | **部分**   | **含义**                                                     |
> | ---------- | ------------------------------------------------------------ |
> | journalctl | 是 systemd 的日志查看工具，用于查看由 systemd 管理的服务日志。所有 systemd 服务（如 ssh、cron、nginx、apache2 等）的输出都会被记录在 systemd 的 journal 中。 |
> | -u cron    | 指定查看 **“cron” 服务单元（unit）** 的日志。这里的 cron 就是 systemd 服务名（相当于 /lib/systemd/system/cron.service）。也可以用 -u ssh.service、-u apache2.service 来看其他服务日志。 |
> | -f         | 表示 **“follow” 模式**，实时跟随输出（类似于 tail -f）。执行后终端会持续输出新的日志内容。 |

9. 扩展：at命令

在Linux系统中，有两个命令可以实现计划任务：crontab和at（第三方，需要额外安装）

crontab：每天定时执行计划任务（最小单元分钟）

at：一次性定时执行任务

* 安装at命令

```bash
# CentOS
dnf install at -y

# Ubuntu
apt install at -y
```

* 启动底层服务

```bash
systemctl start atd
systemctl enable atd
# atd = at + daemon 一般底层服务都有个d
```

* 案例

案例1:3天后下午5点执行`/bin/ls`命令

```bash
# at 5pm+3 days
at>/bin/ls
at>control + D 退出

at 5pm+3 days
warning: commands will be executed using /bin/sh
at Tue Oct 14 17:00:00 2025
at> /bin/ls
at> <EOT>
job 1 at Tue Oct 14 17:00:00 2025
# 查询什么时候执行任务
atq
1       Tue Oct 14 17:00:00 2025 a root
```

案例2:明天下午5点输出当前日期到指定文件

```bash
at 17:00 tomorrow
warning: commands will be executed using /bin/sh
at Sun Oct 12 17:00:00 2025
at> date>/home/matt/readme.txt
at> <EOT>
job 2 at Sun Oct 12 17:00:00 2025
root@Ubuntu:/home/matt# atq
1       Tue Oct 14 17:00:00 2025 a root
2       Sun Oct 12 17:00:00 2025 a root
```

案例3:使用`atq`查看没有执行的计划任务

```bash
atq
```

案例4:删除指定的计划任务

```bash
atq
atrm 编号
```



### Linux软件包管理

所谓的Linux软件包就是Linux系统下的软件安装程序。

**Linux下软件的安装方式**

* RPM软件包安装 => 软件名称.rpm
* Yum软件包工具 => yun install 软件名称 -y
* 源码安装 => 下载软件的源代码 => 编译 => 安装（最麻烦，但是也是最稳定的）

**二进制软件包**

二进制包，也就是源码包经过成功编译之后产生的包。

二进制包是Linux下默认的软件安装包，目前主要有以下2大主流的二进制包管理系统。

* RPM包管理系统：功能强大，安装、升级、查询和卸载非常简单方便，因此许多Linux发行版都默认使用此机制作为软件安装的管理方式，例如Fedora，CentOS，SuSE等
* DPKG包管理系统：由Debian Linux所开发的包管理机制，通过DPKG包，Debian Linux就可以进行软件的管理，主要用在Debian和Ubuntu中。

RPM是Redhat Package Mangement的缩写。

**获取.rpm包**

* 去官网获取：

**查询系统已经安装的软件**

```bash
# CentOS
rpm -qa | grep 软件名称
# Ubuntu
dpkg -l | grep 软件名称
```

**卸载软件包**

```bash
# CentOS
rpm -e 软件名称[选项]
# 选项说明
--nodeps: 强制卸载

# Ubuntu
dpkg -r 软件名称
```

**rpm软件包的安装**

基本语法

```bash
# CentOS
# rpm -ivh 软件包的名称.rpm
选项说明
-i: install 
-v: 是否显示进度条
-h: 表示以"#"方式显示进度条
```

使用 `lsblk(list block devices)`或者 `df -T`查看块设备的信息。

```bash
matt@Ubuntu:~$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
loop0    7:0    0     4K  1 loop /snap/bare/5
loop1    7:1    0  73.9M  1 loop /snap/core22/2133
loop2    7:2    0  73.9M  1 loop /snap/core22/2045
loop4    7:4    0   516M  1 loop /snap/gnome-42-2204/202
loop5    7:5    0  11.1M  1 loop /snap/firmware-updater/167
loop6    7:6    0 247.1M  1 loop /snap/firefox/6836
loop7    7:7    0 516.2M  1 loop /snap/gnome-42-2204/226
loop8    7:8    0  91.7M  1 loop /snap/gtk-common-themes/1535
loop9    7:9    0  10.8M  1 loop /snap/snap-store/1248
loop10   7:10   0  50.8M  1 loop /snap/snapd/25202
loop11   7:11   0   568K  1 loop /snap/snapd-desktop-integration/253
loop12   7:12   0  10.8M  1 loop /snap/snap-store/1270
loop13   7:13   0  49.3M  1 loop /snap/snapd/24792
loop14   7:14   0   576K  1 loop /snap/snapd-desktop-integration/315
loop15   7:15   0 247.6M  1 loop /snap/firefox/6966
sda      8:0    0    10G  0 disk 
├─sda1   8:1    0     1M  0 part 
└─sda2   8:2    0    10G  0 part /
sr0     11:0    1  1024M  0 rom  
matt@Ubuntu:~$ df -T
Filesystem     Type  1K-blocks    Used Available Use% Mounted on
tmpfs          tmpfs    813248    1688    811560   1% /run
/dev/sda2      ext4   10215700 8188228   1486956  85% /
tmpfs          tmpfs   4066236       0   4066236   0% /dev/shm
tmpfs          tmpfs      5120       8      5112   1% /run/lock
tmpfs          tmpfs    813244     140    813104   1% /run/user/1000
```

**rpm软件包的升级**

基本语法：

```bash
# rpm -Uvh 软件包名称.rpm
选项说明
-U：update
```

| **功能**               | **CentOS（RPM）命令**        | **Ubuntu（DPKG）对应命令**                 |
| ---------------------- | ---------------------------- | ------------------------------------------ |
| 安装软件包             | rpm -ivh package.rpm         | sudo dpkg -i package.deb                   |
| 升级软件包             | rpm -Uvh package.rpm         | sudo dpkg -i package.deb（自动覆盖旧版本） |
| 卸载软件包             | rpm -e package_name          | sudo dpkg -r package_name                  |
| 强制卸载（忽略依赖）   | rpm -e --nodeps package_name | sudo dpkg --force-depends -r package_name  |
| 查询已安装包           | rpm -qa                      | dpkg -l                                    |
| 查询某包是否安装       | rpm -q package_name          | dpkg -l                                    |
| 查询包中文件安装位置   | rpm -ql package_name         | dpkg -L package_name                       |
| 查询某个文件属于哪个包 | rpm -qf /path/to/file        | dpkg -S /path/to/file                      |

**rpm扩展**

1. 依赖关系

一个软件必须先有其他软件才能运行，例如Xmind启动过程中提示缺少DLL，成之后为依赖。

为了解决依赖关系问题，有另外一个工具叫做yum(自动解决依赖关系）。

```bash
yum install 软件包名称 -y
```

| **工具**                              | **作用**                                                     | **类比（Ubuntu）** |
| ------------------------------------- | ------------------------------------------------------------ | ------------------ |
| **rpm** (Red Hat Package Manager)     | 最底层的包管理工具，用于安装、卸载、查询 .rpm 包，但不处理依赖关系 | dpkg               |
| **yum** (Yellowdog Updater, Modified) | 在 rpm 之上提供依赖管理和在线仓库支持的高级包管理工具        | apt                |

> 简单来说：
>
> rpm 就像 dpkg（只能装包，不会自动解决依赖）
>
> yum 就像 apt（能联网下载并自动解决依赖）

**现代替代关系（更新的工具）**

| **老工具**          | **新工具** | **说明**                            |
| ------------------- | ---------- | ----------------------------------- |
| yum                 | **dnf**    | CentOS 8 / Fedora 使用 dnf 取代 yum |
| apt-get + apt-cache | **apt**    | Ubuntu 合并命令为统一的 apt         |

**总结对照表**

| **功能**     | **RedHat 系** | **Ubuntu / Debian 系** |
| ------------ | ------------- | ---------------------- |
| 底层包工具   | rpm           | dpkg                   |
| 高级包管理器 | yum / dnf     | apt                    |
| 软件包格式   | .rpm          | .deb                   |

2. 查询文件所属的包名

基本语法：f=file

```bash
# CentOS
# rpm -qf 文件名称

# Ubuntu
dpkg -S 文件
dpkg -S /bin/ls
```

3. 查看软件安装后，生成了那些文件

基本语法：l=list，显示这个软件安装后生成了那些文件

用于列出指定软件包安装的**所有文件路径**（比如可执行文件、配置文件、文档等）。

```bash
# CentOS
# rpm -ql 软件名称

# Ubuntu
# dpkg -L 软件名称

特别说明：软件安装完成后，一共生成以下几类文件
配置文件：/etc目录下
程序文件本身，二进制文件命令 /usr/bin或者/usr/sbin
文档手册：/usr/share/doc或man目录

dpkg -L firefox
/.
/usr
/usr/bin
/usr/bin/firefox
/usr/share
/usr/share/doc
/usr/share/doc/firefox
/usr/share/doc/firefox/changelog.Debian.gz
/usr/share/doc/firefox/copyright
/usr/share/icons
/usr/share/icons/hicolor
/usr/share/icons/hicolor/128x128
/usr/share/icons/hicolor/128x128/apps
/usr/share/icons/hicolor/128x128/apps/firefox.png
/usr/share/icons/hicolor/16x16
/usr/share/icons/hicolor/16x16/apps
/usr/share/icons/hicolor/16x16/apps/firefox.png
/usr/share/icons/hicolor/22x22
/usr/share/icons/hicolor/22x22/apps
/usr/share/icons/hicolor/22x22/apps/firefox.png
/usr/share/icons/hicolor/24x24
/usr/share/icons/hicolor/24x24/apps
/usr/share/icons/hicolor/24x24/apps/firefox.png
/usr/share/icons/hicolor/256x256
/usr/share/icons/hicolor/256x256/apps
/usr/share/icons/hicolor/256x256/apps/firefox.png
/usr/share/icons/hicolor/32x32
/usr/share/icons/hicolor/32x32/apps
/usr/share/icons/hicolor/32x32/apps/firefox.png
/usr/share/icons/hicolor/48x48
/usr/share/icons/hicolor/48x48/apps
/usr/share/icons/hicolor/48x48/apps/firefox.png
/usr/share/icons/hicolor/64x64
/usr/share/icons/hicolor/64x64/apps
/usr/share/icons/hicolor/64x64/apps/firefox.png
/usr/share/icons/hicolor/symbolic
/usr/share/icons/hicolor/symbolic/apps
/usr/share/icons/hicolor/symbolic/apps/firefox-symbolic.svg
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/firefox

dpkg -L openssl
/.
/etc
/etc/ssl
/etc/ssl/certs
/etc/ssl/openssl.cnf
/etc/ssl/private
/usr
/usr/bin
/usr/bin/c_rehash
/usr/bin/openssl
/usr/lib
/usr/lib/ssl
/usr/lib/ssl/misc
/usr/lib/ssl/misc/CA.pl
/usr/lib/ssl/misc/tsget.pl
/usr/share
/usr/share/doc
/usr/share/doc/openssl
/usr/share/doc/openssl/FAQ.md
/usr/share/doc/openssl/HOWTO
/usr/share/doc/openssl/HOWTO/certificates.txt.gz
/usr/share/doc/openssl/HOWTO/keys.txt
/usr/share/doc/openssl/NEWS.md.gz
/usr/share/doc/openssl/README-ENGINES.md.gz
/usr/share/doc/openssl/README.Debian
/usr/share/doc/openssl/README.md.gz
/usr/share/doc/openssl/README.optimization
/usr/share/doc/openssl/fingerprints.txt
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/openssl
/usr/share/man
/usr/share/man/man1
/usr/share/man/man1/CA.pl.1ssl.gz
/usr/share/man/man1/openssl-asn1parse.1ssl.gz
/usr/share/man/man1/openssl-ca.1ssl.gz
/usr/share/man/man1/openssl-ciphers.1ssl.gz
/usr/share/man/man1/openssl-cmds.1ssl.gz
/usr/share/man/man1/openssl-cmp.1ssl.gz
/usr/share/man/man1/openssl-cms.1ssl.gz
/usr/share/man/man1/openssl-crl.1ssl.gz
/usr/share/man/man1/openssl-crl2pkcs7.1ssl.gz
/usr/share/man/man1/openssl-dgst.1ssl.gz
/usr/share/man/man1/openssl-dhparam.1ssl.gz
/usr/share/man/man1/openssl-dsa.1ssl.gz
/usr/share/man/man1/openssl-dsaparam.1ssl.gz
/usr/share/man/man1/openssl-ec.1ssl.gz
/usr/share/man/man1/openssl-ecparam.1ssl.gz
/usr/share/man/man1/openssl-enc.1ssl.gz
/usr/share/man/man1/openssl-engine.1ssl.gz
/usr/share/man/man1/openssl-errstr.1ssl.gz
/usr/share/man/man1/openssl-fipsinstall.1ssl.gz
/usr/share/man/man1/openssl-format-options.1ssl.gz
/usr/share/man/man1/openssl-gendsa.1ssl.gz
/usr/share/man/man1/openssl-genpkey.1ssl.gz
/usr/share/man/man1/openssl-genrsa.1ssl.gz
/usr/share/man/man1/openssl-info.1ssl.gz
/usr/share/man/man1/openssl-kdf.1ssl.gz
/usr/share/man/man1/openssl-list.1ssl.gz
/usr/share/man/man1/openssl-mac.1ssl.gz
/usr/share/man/man1/openssl-namedisplay-options.1ssl.gz
/usr/share/man/man1/openssl-nseq.1ssl.gz
/usr/share/man/man1/openssl-ocsp.1ssl.gz
/usr/share/man/man1/openssl-passphrase-options.1ssl.gz
/usr/share/man/man1/openssl-passwd.1ssl.gz
/usr/share/man/man1/openssl-pkcs12.1ssl.gz
/usr/share/man/man1/openssl-pkcs7.1ssl.gz
/usr/share/man/man1/openssl-pkcs8.1ssl.gz
/usr/share/man/man1/openssl-pkey.1ssl.gz
/usr/share/man/man1/openssl-pkeyparam.1ssl.gz
/usr/share/man/man1/openssl-pkeyutl.1ssl.gz
/usr/share/man/man1/openssl-prime.1ssl.gz
/usr/share/man/man1/openssl-rand.1ssl.gz
/usr/share/man/man1/openssl-rehash.1ssl.gz
/usr/share/man/man1/openssl-req.1ssl.gz
/usr/share/man/man1/openssl-rsa.1ssl.gz
/usr/share/man/man1/openssl-rsautl.1ssl.gz
/usr/share/man/man1/openssl-s_client.1ssl.gz
/usr/share/man/man1/openssl-s_server.1ssl.gz
/usr/share/man/man1/openssl-s_time.1ssl.gz
/usr/share/man/man1/openssl-sess_id.1ssl.gz
/usr/share/man/man1/openssl-smime.1ssl.gz
/usr/share/man/man1/openssl-speed.1ssl.gz
/usr/share/man/man1/openssl-spkac.1ssl.gz
/usr/share/man/man1/openssl-srp.1ssl.gz
/usr/share/man/man1/openssl-storeutl.1ssl.gz
/usr/share/man/man1/openssl-ts.1ssl.gz
/usr/share/man/man1/openssl-verification-options.1ssl.gz
/usr/share/man/man1/openssl-verify.1ssl.gz
/usr/share/man/man1/openssl-version.1ssl.gz
/usr/share/man/man1/openssl-x509.1ssl.gz
/usr/share/man/man1/openssl.1ssl.gz
/usr/share/man/man1/tsget.1ssl.gz
/usr/share/man/man5
/usr/share/man/man5/config.5ssl.gz
/usr/share/man/man5/fips_config.5ssl.gz
/usr/share/man/man5/x509v3_config.5ssl.gz
/usr/share/man/man7
/usr/share/man/man7/EVP_ASYM_CIPHER-RSA.7ssl.gz
/usr/share/man/man7/EVP_ASYM_CIPHER-SM2.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-AES.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-ARIA.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-BLOWFISH.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-CAMELLIA.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-CAST.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-CHACHA.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-DES.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-IDEA.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-NULL.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-RC2.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-RC4.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-RC5.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-SEED.7ssl.gz
/usr/share/man/man7/EVP_CIPHER-SM4.7ssl.gz
/usr/share/man/man7/EVP_KDF-HKDF.7ssl.gz
/usr/share/man/man7/EVP_KDF-KB.7ssl.gz
/usr/share/man/man7/EVP_KDF-KRB5KDF.7ssl.gz
/usr/share/man/man7/EVP_KDF-PBKDF1.7ssl.gz
/usr/share/man/man7/EVP_KDF-PBKDF2.7ssl.gz
/usr/share/man/man7/EVP_KDF-PKCS12KDF.7ssl.gz
/usr/share/man/man7/EVP_KDF-SCRYPT.7ssl.gz
/usr/share/man/man7/EVP_KDF-SS.7ssl.gz
/usr/share/man/man7/EVP_KDF-SSHKDF.7ssl.gz
/usr/share/man/man7/EVP_KDF-TLS13_KDF.7ssl.gz
/usr/share/man/man7/EVP_KDF-TLS1_PRF.7ssl.gz
/usr/share/man/man7/EVP_KDF-X942-ASN1.7ssl.gz
/usr/share/man/man7/EVP_KDF-X942-CONCAT.7ssl.gz
/usr/share/man/man7/EVP_KDF-X963.7ssl.gz
/usr/share/man/man7/EVP_KEM-RSA.7ssl.gz
/usr/share/man/man7/EVP_KEYEXCH-DH.7ssl.gz
/usr/share/man/man7/EVP_KEYEXCH-ECDH.7ssl.gz
/usr/share/man/man7/EVP_KEYEXCH-X25519.7ssl.gz
/usr/share/man/man7/EVP_MAC-BLAKE2.7ssl.gz
/usr/share/man/man7/EVP_MAC-CMAC.7ssl.gz
/usr/share/man/man7/EVP_MAC-GMAC.7ssl.gz
/usr/share/man/man7/EVP_MAC-HMAC.7ssl.gz
/usr/share/man/man7/EVP_MAC-KMAC.7ssl.gz
/usr/share/man/man7/EVP_MAC-Poly1305.7ssl.gz
/usr/share/man/man7/EVP_MAC-Siphash.7ssl.gz
/usr/share/man/man7/EVP_MD-BLAKE2.7ssl.gz
/usr/share/man/man7/EVP_MD-MD2.7ssl.gz
/usr/share/man/man7/EVP_MD-MD4.7ssl.gz
/usr/share/man/man7/EVP_MD-MD5-SHA1.7ssl.gz
/usr/share/man/man7/EVP_MD-MD5.7ssl.gz
/usr/share/man/man7/EVP_MD-MDC2.7ssl.gz
/usr/share/man/man7/EVP_MD-NULL.7ssl.gz
/usr/share/man/man7/EVP_MD-RIPEMD160.7ssl.gz
/usr/share/man/man7/EVP_MD-SHA1.7ssl.gz
/usr/share/man/man7/EVP_MD-SHA2.7ssl.gz
/usr/share/man/man7/EVP_MD-SHA3.7ssl.gz
/usr/share/man/man7/EVP_MD-SHAKE.7ssl.gz
/usr/share/man/man7/EVP_MD-SM3.7ssl.gz
/usr/share/man/man7/EVP_MD-WHIRLPOOL.7ssl.gz
/usr/share/man/man7/EVP_MD-common.7ssl.gz
/usr/share/man/man7/EVP_PKEY-DH.7ssl.gz
/usr/share/man/man7/EVP_PKEY-DSA.7ssl.gz
/usr/share/man/man7/EVP_PKEY-EC.7ssl.gz
/usr/share/man/man7/EVP_PKEY-FFC.7ssl.gz
/usr/share/man/man7/EVP_PKEY-HMAC.7ssl.gz
/usr/share/man/man7/EVP_PKEY-RSA.7ssl.gz
/usr/share/man/man7/EVP_PKEY-SM2.7ssl.gz
/usr/share/man/man7/EVP_PKEY-X25519.7ssl.gz
/usr/share/man/man7/EVP_RAND-CTR-DRBG.7ssl.gz
/usr/share/man/man7/EVP_RAND-HASH-DRBG.7ssl.gz
/usr/share/man/man7/EVP_RAND-HMAC-DRBG.7ssl.gz
/usr/share/man/man7/EVP_RAND-SEED-SRC.7ssl.gz
/usr/share/man/man7/EVP_RAND-TEST-RAND.7ssl.gz
/usr/share/man/man7/EVP_RAND.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-DSA.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-ECDSA.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-ED25519.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-HMAC.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-RSA.7ssl.gz
/usr/share/man/man7/OSSL_PROVIDER-FIPS.7ssl.gz
/usr/share/man/man7/OSSL_PROVIDER-base.7ssl.gz
/usr/share/man/man7/OSSL_PROVIDER-default.7ssl.gz
/usr/share/man/man7/OSSL_PROVIDER-legacy.7ssl.gz
/usr/share/man/man7/OSSL_PROVIDER-null.7ssl.gz
/usr/share/man/man7/RAND.7ssl.gz
/usr/share/man/man7/RSA-PSS.7ssl.gz
/usr/share/man/man7/X25519.7ssl.gz
/usr/share/man/man7/bio.7ssl.gz
/usr/share/man/man7/crypto.7ssl.gz
/usr/share/man/man7/ct.7ssl.gz
/usr/share/man/man7/des_modes.7ssl.gz
/usr/share/man/man7/evp.7ssl.gz
/usr/share/man/man7/fips_module.7ssl.gz
/usr/share/man/man7/life_cycle-cipher.7ssl.gz
/usr/share/man/man7/life_cycle-digest.7ssl.gz
/usr/share/man/man7/life_cycle-kdf.7ssl.gz
/usr/share/man/man7/life_cycle-mac.7ssl.gz
/usr/share/man/man7/life_cycle-pkey.7ssl.gz
/usr/share/man/man7/life_cycle-rand.7ssl.gz
/usr/share/man/man7/migration_guide.7ssl.gz
/usr/share/man/man7/openssl-core.h.7ssl.gz
/usr/share/man/man7/openssl-core_dispatch.h.7ssl.gz
/usr/share/man/man7/openssl-core_names.h.7ssl.gz
/usr/share/man/man7/openssl-env.7ssl.gz
/usr/share/man/man7/openssl-glossary.7ssl.gz
/usr/share/man/man7/openssl-threads.7ssl.gz
/usr/share/man/man7/openssl_user_macros.7ssl.gz
/usr/share/man/man7/ossl_store-file.7ssl.gz
/usr/share/man/man7/ossl_store.7ssl.gz
/usr/share/man/man7/passphrase-encoding.7ssl.gz
/usr/share/man/man7/property.7ssl.gz
/usr/share/man/man7/provider-asym_cipher.7ssl.gz
/usr/share/man/man7/provider-base.7ssl.gz
/usr/share/man/man7/provider-cipher.7ssl.gz
/usr/share/man/man7/provider-decoder.7ssl.gz
/usr/share/man/man7/provider-digest.7ssl.gz
/usr/share/man/man7/provider-encoder.7ssl.gz
/usr/share/man/man7/provider-kdf.7ssl.gz
/usr/share/man/man7/provider-kem.7ssl.gz
/usr/share/man/man7/provider-keyexch.7ssl.gz
/usr/share/man/man7/provider-keymgmt.7ssl.gz
/usr/share/man/man7/provider-mac.7ssl.gz
/usr/share/man/man7/provider-object.7ssl.gz
/usr/share/man/man7/provider-rand.7ssl.gz
/usr/share/man/man7/provider-signature.7ssl.gz
/usr/share/man/man7/provider-storemgmt.7ssl.gz
/usr/share/man/man7/provider.7ssl.gz
/usr/share/man/man7/proxy-certificates.7ssl.gz
/usr/share/man/man7/ssl.7ssl.gz
/usr/share/man/man7/x509.7ssl.gz
/usr/lib/ssl/cert.pem
/usr/lib/ssl/certs
/usr/lib/ssl/misc/tsget
/usr/lib/ssl/openssl.cnf
/usr/lib/ssl/private
/usr/share/doc/openssl/changelog.Debian.gz
/usr/share/doc/openssl/changelog.gz
/usr/share/doc/openssl/copyright
/usr/share/man/man1/asn1parse.1ssl.gz
/usr/share/man/man1/c_rehash.1ssl.gz
/usr/share/man/man1/ca.1ssl.gz
/usr/share/man/man1/ciphers.1ssl.gz
/usr/share/man/man1/cmp.1ssl.gz
/usr/share/man/man1/cms.1ssl.gz
/usr/share/man/man1/crl.1ssl.gz
/usr/share/man/man1/crl2pkcs7.1ssl.gz
/usr/share/man/man1/dgst.1ssl.gz
/usr/share/man/man1/dhparam.1ssl.gz
/usr/share/man/man1/dsa.1ssl.gz
/usr/share/man/man1/dsaparam.1ssl.gz
/usr/share/man/man1/ec.1ssl.gz
/usr/share/man/man1/ecparam.1ssl.gz
/usr/share/man/man1/enc.1ssl.gz
/usr/share/man/man1/engine.1ssl.gz
/usr/share/man/man1/errstr.1ssl.gz
/usr/share/man/man1/gendsa.1ssl.gz
/usr/share/man/man1/genpkey.1ssl.gz
/usr/share/man/man1/genrsa.1ssl.gz
/usr/share/man/man1/info.1ssl.gz
/usr/share/man/man1/kdf.1ssl.gz
/usr/share/man/man1/mac.1ssl.gz
/usr/share/man/man1/nseq.1ssl.gz
/usr/share/man/man1/ocsp.1ssl.gz
/usr/share/man/man1/passwd.1ssl.gz
/usr/share/man/man1/pkcs12.1ssl.gz
/usr/share/man/man1/pkcs7.1ssl.gz
/usr/share/man/man1/pkcs8.1ssl.gz
/usr/share/man/man1/pkey.1ssl.gz
/usr/share/man/man1/pkeyparam.1ssl.gz
/usr/share/man/man1/pkeyutl.1ssl.gz
/usr/share/man/man1/prime.1ssl.gz
/usr/share/man/man1/rand.1ssl.gz
/usr/share/man/man1/rehash.1ssl.gz
/usr/share/man/man1/req.1ssl.gz
/usr/share/man/man1/rsa.1ssl.gz
/usr/share/man/man1/rsautl.1ssl.gz
/usr/share/man/man1/s_client.1ssl.gz
/usr/share/man/man1/s_server.1ssl.gz
/usr/share/man/man1/s_time.1ssl.gz
/usr/share/man/man1/sess_id.1ssl.gz
/usr/share/man/man1/smime.1ssl.gz
/usr/share/man/man1/speed.1ssl.gz
/usr/share/man/man1/spkac.1ssl.gz
/usr/share/man/man1/srp.1ssl.gz
/usr/share/man/man1/storeutl.1ssl.gz
/usr/share/man/man1/ts.1ssl.gz
/usr/share/man/man1/verify.1ssl.gz
/usr/share/man/man1/version.1ssl.gz
/usr/share/man/man1/x509.1ssl.gz
/usr/share/man/man7/EVP_KEYEXCH-X448.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-CMAC.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-DH.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-DHX.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-DSA.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-EC.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-ED25519.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-ED448.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-HMAC.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-Poly1305.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-RSA.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-SM2.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-Siphash.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-X25519.7ssl.gz
/usr/share/man/man7/EVP_KEYMGMT-X448.7ssl.gz
/usr/share/man/man7/EVP_MAC-BLAKE2BMAC.7ssl.gz
/usr/share/man/man7/EVP_MAC-BLAKE2SMAC.7ssl.gz
/usr/share/man/man7/EVP_MAC-KMAC128.7ssl.gz
/usr/share/man/man7/EVP_MAC-KMAC256.7ssl.gz
/usr/share/man/man7/EVP_MD-KECCAK-KMAC.7ssl.gz
/usr/share/man/man7/EVP_PKEY-CMAC.7ssl.gz
/usr/share/man/man7/EVP_PKEY-DHX.7ssl.gz
/usr/share/man/man7/EVP_PKEY-ED25519.7ssl.gz
/usr/share/man/man7/EVP_PKEY-ED448.7ssl.gz
/usr/share/man/man7/EVP_PKEY-Poly1305.7ssl.gz
/usr/share/man/man7/EVP_PKEY-Siphash.7ssl.gz
/usr/share/man/man7/EVP_PKEY-X448.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-CMAC.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-ED448.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-Poly1305.7ssl.gz
/usr/share/man/man7/EVP_SIGNATURE-Siphash.7ssl.gz
/usr/share/man/man7/Ed25519.7ssl.gz
/usr/share/man/man7/Ed448.7ssl.gz
/usr/share/man/man7/OPENSSL_API_COMPAT.7ssl.gz
/usr/share/man/man7/OPENSSL_NO_DEPRECATED.7ssl.gz
/usr/share/man/man7/RSA.7ssl.gz
/usr/share/man/man7/SM2.7ssl.gz
/usr/share/man/man7/X448.7ssl.gz
```

**光盘的挂载与解挂**

在Linux操作系统中，所有的存储设备都必须先挂载然后才能使用。

1. 解挂

```bash
# umount 目录
```

常见问题

当我们执行这个命令时，提示device is busy！
出现以上原因通常是由于当前所在目录就是挂载目录。

2. 挂载

```bash
# mount 设备文件 挂载目录
mkdir /mnt/cdrom
mount /dev/sr0 /mnt/cdrom
```



## Linux进程检测与控制

### 引言

在运维的日常工作中，监视系统的运行状况是每天例行的工作，在windows中我们可以很直观的使用“任务管理器”来进行进程管理，了解系统的运行状态。

通常，使用任务管理器主要有3个目的：

1. 利用"应用程序"和"进程"标签来查看系统中到底运行了哪些进程和程序
2. 利用"性能"和"用户"标签来判断服务器的健康状态
3. 在"应用程序"和"进程"标签中强制终止任务和进程

在工作中，我们很少会用到Linux的图形化界面，更多时候使用命令进行进程管理。但是进程管理的目的是一样的，即：

* 查看系统中运行的程序和进程
* 判断服务的健康状态
* 停止不需要的进程

### 进程与程序的关系

进程是正在执行的一个程序或者命令，每个进程都是一个运行的实体，并占用一定的系统资源。程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码的集合。

举例：谷歌浏览器是一个程序，当我们打开谷歌浏览器，就会在系统中看到一个谷歌浏览器的进程，当进程被执行时，程序的代码都会被加载到内存，操作系统给这个进程分配一个ID，称为PID（进程ID）。我们打开多个谷歌浏览器，就有多个浏览器子程序，但是这些进程使用的程序，都是chrome。

> PID = Process ID（进程ID） 

### Linux下进程管理工作

* 进程查看，通过查看，判断健康状态；

* 进程终止

* 进程优先级控制

### Linux下进程管理命令

**任务背景**

工作场景：小张进入一家公司，接到的第一项任务，监控生产服务器的性能，提到服务器性能，我们首先想到的是CPU，内存和磁盘。

**使用top命令动态监测CPU信息**

基本语法

```bash
top
```

![image-20251011174636023](/Users/matt/Desktop/Learning/learning_notes/notes/images/top.png)

**系统的整体情况**

![image-20251011174817599](/Users/matt/Desktop/Learning/learning_notes/notes/images/top2png.png)

* 第一行

| 内容                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 09:49:00                       | 系统当前时间                                                 |
| up  6:47                       | 系统的运行时间，本机已经运行6小时47分钟                      |
| 3 users                        | 当前登录了3个用户                                            |
| load average: 0.05, 0.02, 0.00 | 系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核的，这个数值超过1就是高负载，如果CPU是4核的，则这个数值超过4就是高负载 |

* 第二行

| 内容             | 说明                                          |
| ---------------- | --------------------------------------------- |
| Tasks: 255 total | 系统中的进程总数                              |
| 1 running        | 正在运行的进程数                              |
| 254 sleeping     | 睡眠的进程数                                  |
| 0 stopped        | 正在停止的进程数                              |
| 0 zombie         | 僵尸进程数，如果不是0，则需要手工检查检视进程 |

> 如何获取CPU的总核心数
>
> `grep 'core id' /proc/cpuinfo | sort -u | wc -l`

* 第3行

| 内容             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| %Cpu(s):  0.1 us | 用户模式占用的CPU百分比                                      |
| 0.0 sy           | 系统模式占用的CPU百分比                                      |
| 0.0 ni           | 改变过优先级的用户进程占用的CPU百分比                        |
| 99.8 id          | idle缩写，空闲CPU占用的CPU百分比                             |
| 0.0 wa           | 等待输入/输出的进程占用的CPU百分比                           |
| 0.0 hi           | 硬中断请求服务占用的CPU百分比                                |
| 0.1 si           | 软中断请求服务占用的CPU百分比                                |
| 0.0 st           | st（steal time）意味虚拟时间百分比，就是当有虚拟机时，虚拟机CPU等待实际CPU的时间百分比 |

> 如果我的服务器核心数是4核的，如何查看每一个核心分别的负载情况？
>
> 答案：按下数字键1来回切换

![image-20251011204649262](/Users/matt/Desktop/Learning/learning_notes/notes/images/top3.png)

> CPU负载测试：`cat /dev/urandom | md5sum`
>
> **生成一个随机的 MD5 哈希字符串**
>
> - /dev/urandom
>
>   是 Linux 系统的一个**伪随机数生成器**，会不断输出随机字节流。
>
> - cat /dev/urandom
>
>   意思是读取这个随机字节流并输出到标准输出。
>
> - |（管道符）
>
>   把前面 cat 的输出作为后面命令的输入。
>
> - md5sum
>
>   计算输入数据的 **MD5 哈希值**。
>
> e4f7b4a2d1c8124f03b6a38e98cbdd53 

![image-20251011204927227](/Users/matt/Desktop/Learning/learning_notes/notes/images/top4.png)

* 第4行

| 内容                     | 说明                     |
| ------------------------ | ------------------------ |
| MiB Mem :   7941.9 total | 物理内存的总量，单位为MB |
| 5952.0 free              | 空闲的物理内存总数       |
| 1150.1 used              | 已经使用的物理内存总数   |
| 1111.9 buff/cache        | 作为缓冲的内存总数       |

> 扩展：真正剩余内存=free+buff/cache，真正使用的内存=used-buff/cache

* 第5行

| 内容                     | 说明                         |
| ------------------------ | ---------------------------- |
| MiB Swap:      0.0 total | 交换分区（虚拟内存）的总大小 |
| 0.0 free                 | 空闲交换分区的大小           |
| 0.0 used                 | 已经使用的交换分区的大小     |
| 6790.9 avail Mem         | 可用内存                     |

在Linux系统分区时，最少需要3个分区：

1. /boot分区：系统分区
2. /swap交换分区：一般情况下为内存的1-2倍，但是尽量不超过2G
3. /分区：根分区，所有文件都存放在此

> swap分区：就是当计算机的内存不足时，系统会自动从硬盘中划出一块区域充当内存使用。

> 通过以上信息中的平均负载，cpu使用情况以及内存使用情况，可以看出，目前的系统处于空闲状态。

如果发现CPU负载过大，接下来怎么办？

查看CPU占用最多的进程。

如果1分钟，5分钟和15分钟的全部超过CPU的总核心数（必须引起警觉）。

> 经验之谈：如果一个总核心数=8的cpu，理论上平均负载达到16，也还可以坚持很长一段时间。

**系统的进程信息**

![image-20251011212453871](/Users/matt/Desktop/Learning/learning_notes/notes/images/top6.png)

| 内容    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| PID     | 进程ID                                                       |
| USER    | 该进程所属的用户                                             |
| PR      | 优先级，数值越小优先级越高                                   |
| NI      | NICE优先级，数值越小优先级越高，取值范围-20～19，默认都是0   |
| VIRT    | 该进程使用的虚拟内存大小，单位为kb                           |
| RES     | 该进程使用的物理内存大小，单位为kb                           |
| SHR     | 共享内存大小，单位为kb，计算一个进程实际使用的内存=常驻内存（RES）- 共享内存（SHR） |
| S       | 进程状态，其中S表示睡眠，R表示运行                           |
| %CPU    | 该进程占用的CPU百分比                                        |
| %MEM    | 该进程占用的内存百分比                                       |
| TIME+   | 该进程占用的CPU时间                                          |
| COMMAND | 进程名                                                       |

如何查看占用CPU最多的进程？

交互操作快捷键P，表示将结果按照CPU的使用率从高到低进行降序排列。

如果发现内存可用量很小，怎么办？

查看占用内存最多的进程，使用交互式快捷键M（大写），表示将结果按照（MEM）从高到低进行排序。

**free查看系统内存的使用情况**

基本语法

```bash
# free [选项]
选项说明
-m：以MB的形式显示内存大小

# 显示计算机使用情况
free
# 以MB形式显示
free -m
```

```bash
               total        used        free      shared  buff/cache   available
Mem:            7941        1143        6142          31         921        6798
Swap:              0           0           0
```

和CentOS6相比，buffer和cached合成一组，加入了一个available。

关于此available，即系统可用内存。用户不需要去计算buff/cache，即可以看到还有多少内存可用，更加简单直观。

* 第一行

| 内容       | 说明             |
| ---------- | ---------------- |
| total      | 内存总数         |
| userd      | 已经使用的内存数 |
| free       | 空闲的内存数     |
| shared     | 共享内存数       |
| buff/cache | 块设备缓存区内存 |
| available  | 可用内存数       |

* 第二行

第二行数据是swap交换区，也就是我们通常所说的虚拟内存，可以在内存不够使用的情况下当临时内存来使用，交换分区不是越大越好，一般它就等于实际内存的大小。

**df查看磁盘的剩余空间**

基本语法

```bash
# df [选项]
选项说明
-h: 以较高的可读性显示磁盘的大小
```

> df = disk free = 磁盘剩余

```bash
df -h
Filesystem      Size  Used Avail Use% Mounted on
tmpfs           795M  1.5M  793M   1% /run
/dev/sda2       9.8G  8.0G  1.4G  86% /
tmpfs           3.9G     0  3.9G   0% /dev/shm
tmpfs           5.0M  8.0K  5.0M   1% /run/lock
tmpfs           795M  128K  795M   1% /run/user/1000
```

| 内容       | 说明                              |
| ---------- | --------------------------------- |
| Filesystem | 磁盘名称                          |
| Size       | 总大小                            |
| Used       | 被使用的大小                      |
| Avail      | 剩余大小                          |
| Use%       | 使用百分比                        |
| Mounted on | 挂载路径（相当于Windows的磁盘符） |

**ps查看系统进程信息**

top：动态查看系统进程状态（每隔3秒刷新一次）

ps：静态查看系统进程信息（只能查看运行ps瞬间，系统的进程信息）

基本语法

```bash
# ps [选项]
选项说明
-e: 等价于 "A", 表示列出全部的进程
-f: 表示full，显示全部的列
```

![image-20251012095159283](/Users/matt/Desktop/Learning/learning_notes/notes/images/ps.png)

| 内容  | 名称                                                         |
| ----- | ------------------------------------------------------------ |
| UID   | 该进程执行的用户ID                                           |
| PID   | 进程ID                                                       |
| PPID  | 该进程的父进程ID，如果找不到，则该进程被称为僵尸进程（Parent Process ID） |
| C     | CPU的占用率，其形式是百分比                                  |
| STIME | 进程的启动时间                                               |
| TTY   | 终端设备，发起该进程的设备识别符号，如果显示？则表示该进程不是由终端发起 |
| TIME  | 进程实际使用CPU时间                                          |
| CMD   | 该进程的名称或者对应的路径                                   |

> 经验之谈：我们在实际工作中，使用ps命令其实主要用于查询某个进程的PID或者PPID。

```bash
# ps -ef | grep 要查看的进程名称
ps -ef | grep cron
root        3810       1  0 Oct13 ?        00:00:00 /usr/sbin/cron -f -P
matt       27096   27021  0 12:09 pts/2    00:00:00 grep --color=auto cron
ps -ef | grep sshd
root        1429       1  0 01:11 ?        00:00:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
root        3258    1429  0 01:17 ?        00:00:00 sshd: matt [priv]
matt        3324    3258  0 01:17 ?        00:00:00 sshd: matt@pts/1
matt        3598    3325  0 02:06 pts/1    00:00:00 grep --color=auto sshd
```

> 注意：查询结果中，如果只有一条则表示没有查到对应的进程（这1表示刚才ps指令自身）。只有查到的结果多余1条，才表示对应的进程。

可以使用`grep -v  ”要过滤掉的名称“`过滤掉grep进程

```bash
ps -ef | grep sshd | grep -v "grep"
root        1429       1  0 01:11 ?        00:00:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
root        3258    1429  0 01:17 ?        00:00:00 sshd: matt [priv]
matt        3324    3258  0 01:17 ?        00:00:00 sshd: matt@pts/1
```

> 扩展：ps aux
>
> | **参数** | **含义**                                                     |
> | -------- | ------------------------------------------------------------ |
> | **a**    | 显示所有用户的进程（不仅仅是当前用户的）                     |
> | **u**    | 以用户为中心的格式显示进程信息（包含用户名、CPU 使用率、内存占用等） |
> | **x**    | 显示没有控制终端（tty）的进程（例如后台服务）                |

```bash
ps aux
```

![image-20251012101316508](/Users/matt/Desktop/Learning/learning_notes/notes/images/ps02.png)

```bash
man ps
This version of ps accepts several kinds of options:
1   UNIX options, which may be grouped and must be preceded by a dash.
2   BSD options, which may be grouped and must not be used with a dash.
3   GNU long options, which are preceded by two dashes.
```

| 内容     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| USER     | 该进程属于哪个使用者账号                                     |
| **PID**  | 进程ID                                                       |
| **%CPU** | 该进程使用掉的CPU资源百分比                                  |
| **%MEM** | 该进程所占用的物理内存百分比                                 |
| VSZ      | 该进程用掉的虚拟内存量                                       |
| RSS      | 该进程占用的固定内存量                                       |
| TTY      | 该进程是在哪个终端上运作，若与终端无关，则显示？，另外tty1-tty6是本机上面的登录程序，如果pts/0等等的，则表示为由网络连接进主机的程序 |
| STAT     | 该程序目前的状态，主要的状态有：R-该进程目前正在运行，或可被运作，S-该进程目前处于睡眠状态中，但可能被某些信号唤醒，T-该进程目前正在侦测或者停止了，Z-该程序应该已经终止，但是其父程序却无法正常的终止他，造成zobie（僵尸）程序的状态。 |
| TIME     | 该进程实际使用Cpu的时间                                      |
| COMMAND  | 该程序的实际指令                                             |
| START    | 该进程触发启动的时间                                         |

**netstat查看网络访问信息**

netstat 用于查看网络连接、路由表、接口状态等信息。

基本语法：

```bash
# netstat [选项] | grep 进程名称
选项说明
-t：表示只列出top协议的连接（tcp协议与udp协议）
-n：以 数字形式 显示地址和端口（不解析成域名或服务名） 10.1.1.10:80
-l：仅显示 监听中（Listening） 的端口
-p：显示监听端口的 进程 PID 和程序名（需要 root 权限）
```

查询web server（httpd）服务的端口信息

```bash
# CentOS
netstat -tnlp | grep httpd

# Ubuntu
netstat -tnlp | grep apache2
tcp6       0      0 :::80                   :::*                    LISTEN      1431/apache2 

netstat -tnlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.54:53           0.0.0.0:*               LISTEN      550/systemd-resolve 
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1353/cupsd          
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1/init              
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      550/systemd-resolve 
tcp6       0      0 ::1:631                 :::*                    LISTEN      1353/cupsd          
tcp6       0      0 :::22                   :::*                    LISTEN      1/init              
tcp6       0      0 :::80                   :::*                    LISTEN      1431/apache2  
```

| **字段**             | **含义**                          |
| -------------------- | --------------------------------- |
| **Proto**            | 协议类型（tcp / tcp6）            |
| **Recv-Q / Send-Q**  | 接收/发送队列（正常情况下应为 0） |
| **Local Address**    | 本地监听的 IP 和端口              |
| **Foreign Address**  | 远程地址（* 表示任意）            |
| **State**            | 连接状态（LISTEN 表示正在监听）   |
| **PID/Program name** | 对应的进程号和程序名              |

| **示例**              | **协议版本** | **含义**                           | **实际意义**                            |
| --------------------- | ------------ | ---------------------------------- | --------------------------------------- |
| **0.0.0.0:22**        | IPv4         | 在所有 IPv4 网络接口上监听 22 端口 | SSH 服务可以被任何 IPv4 地址访问        |
| **:::80**             | IPv6         | 在所有 IPv6 网络接口上监听 80 端口 | Web 服务（HTTP）可被 IPv6/IPv4 地址访问 |
| **127.0.0.1:3306**    | IPv4         | 仅在本机回环接口监听               | 只能在服务器本地访问 MySQL              |
| **192.168.1.10:8080** | IPv4         | 仅监听该指定网卡                   | 只允许通过该网卡访问                    |

扩展：

`ss -naltp` 是 Linux 中一个非常常用的网络诊断命令，用来显示当前系统的 **TCP 连接**、**监听端口**、**对应进程** 等信息。

基本语法

```bash
ss -naltp
```

| **选项** | **含义**                                                     |
| -------- | ------------------------------------------------------------ |
| **-n**   | 不解析域名和服务名，直接显示数字（例如显示 80 而不是 http，显示 IP 而不是主机名） |
| **-a**   | 显示所有的套接字（包括监听状态 LISTEN 和已建立连接的）       |
| **-l**   | 只显示监听状态的套接字（Listen sockets）                     |
| **-t**   | 只显示 TCP 连接（不包括 UDP）                                |
| **-p**   | 显示使用该端口的进程和 PID（需要 root 权限）                 |

```bash
# ss -naltp | grep 进程名称

ss -naltp | grep apache2
LISTEN 0      511                *:80              *:*    users:(("apache2",pid=1435,fd=3),("apache2",pid=1434,fd=3),("apache2",pid=1431,fd=3))
```

> netstat和ss的区别：
>
> * netstat信息比较简洁，ss更加丰富
> * ss执行效率比netstat略高一些

![image-20251012164142935](/Users/matt/Desktop/Learning/learning_notes/notes/images/ss01.png)

| **列名**               | **含义**                                          |
| ---------------------- | ------------------------------------------------- |
| **State**              | 当前连接状态（LISTEN, ESTAB, CLOSE-WAIT 等）      |
| **Recv-Q / Send-Q**    | 接收队列 / 发送队列中积压的数据包数量（一般为 0） |
| **Local Address:Port** | 本地监听的 IP 地址和端口号                        |
| **Peer Address:Port**  | 对端（远程）IP 地址和端口号，* 表示任意           |
| **Process**            | 当前使用该端口的进程名和 PID                      |

**kill/killall杀死进程**

命令kill 

基本语法

```bash
# kill [信号] PID
信号：
9：杀死进程，即强制结束进程
15: 正常结束进程，是kill命令的默认信号
```

作用：kill命令会向操作系统发送一个信号（多是终端信号）和目标进程的PID，然后系统根据接收到的信号类型，对指定进程进行相应的操作。

> 这个命令通常结合ps一起使用。

案例：杀掉cron进程

```bash
ps -ef | grep cron
root         804       1  0 01:11 ?        00:00:00 /usr/sbin/cron -f -P
root        3800    3735  0 02:50 pts/1    00:00:00 grep --color=auto cron*

kill 804
ps -ef | grep cron*
root        3806    3735  0 02:50 pts/1    00:00:00 grep --color=auto cron*

systemctl start cron
ps -ef | grep cron*
root        3810       1  0 02:51 ?        00:00:00 /usr/sbin/cron -f -P
root        3812    3735  0 02:51 pts/1    00:00:00 grep --color=auto cron*
```

根据进程名称杀掉进程

基本语法

```bash
# killall [信号编号] 进程名称
```

```bash
# 杀死dron进程
killall cron

# apache2 有多个进程
方法1: 可以找到父进程，杀掉父进程后，子进程也会被杀掉
方法2: 使用killall apache2 杀掉所有相关进程
killall apache2

ps -ef | grep apache2
root        3831    3735  0 02:56 pts/1    00:00:00 grep --color=auto apache2
```

```bash
pkill：按 进程名、用户名、终端、会话等条件 杀进程
pkill nginx
pkill -u ubuntu
pkill -f "node server.js"
```

- pkill 根据 **进程名称（或模式匹配）** 来杀死对应的进程。
- 无需先查 PID，非常方便。
- 支持正则匹配、用户过滤等高级选项。

**进程的优先级**

1. 什么是进程的优先级

Linux是一个多用户、多任务的操作系统，系统中通常运行着非常多的进程，哪些进程先运行，哪些进程后运行，就是由进程的优先级来控制的。

什么时候要用到进程的优先级呢？

当CPU负载过高时，如CPU的使用率大于90%以上，这个时候进程的优先级就会起作用。

2. 查看进程的优先级

PR：进程优先级，数值越小优先级越高

NI：优先级，数值越小优先级越高，可以人为修改。（NI=NICE=Nice），范围在-20～19

> 可以通过top命令查看这两个优先级

3. 调整进程的优先级

* 使用top命令调整进程的优先级

第一步：使用top命令查看要调整的进程的信息

```bash
# 以非交互模式运行一次 top 命令，并输出结果。
# -b 批处理模式（batch mode）：以非交互方式输出，适合脚本或日志分析。不会进入 top 的实时界面。
# -n 1 刷新次数（iterations）：只执行 1 次更新，然后退出。
top -bn 1
PID COMMAND
875 atd(at命令的底层服务)
```

第二步：运行top，然后按"r", 输入要调整进程的PID

```bash
top 
# 然后按r
```

第三步：根据提示，输入NICE值(需要root权限)

```bash
PID to renice [default pid = 1352] 875
Renice PID 875 to value -5
```

第四步：按q退出top模式，然后使用 `top -p PID`，查询某个进程的信息

```bash
top -p 875
```

**使用renice调整进程的优先级**

基本语法

```bash
# renice [MI优先级要设置的数字] 进程PID
```

使用renice调整atd的进程优先级

```bash
# 1.查询对应的PID
ps -ef | grep atq
# 2. 更改进程优先级
renice -8 875
875 (process ID) old priority -10, new priority -8
```

**使用nice命令调整进程的优先级**

基本语法

```bash
# nice [NI优先级设置的数字] 想调整的进程名称
```

> 注意：nice命令只能调整没有运行的程序

第一步：停止程序

```bash
ps -ef | grep atd
kill PID
或者
systemctl stop atd
```

第二步：启动并制定优先级

```bash
nice -n -10 atd
```

> nice命令包含两个功能：1. 启动程序；2. 修改进程优先级

第三步：确认优先级

```bash
ps -ef | grep atd
top -p PID
```



## LAMP项目部署实战

### YUM

**什么是Yum**

在CentOS中，软件的安装方式由3种：rpm安装，yum安装以及编译安装。

编译安装 > rpm安装 > yum安装（网络 + yum源）

Yum（全称yellow dog updater，modified）是一个在Fedora和RedHat以及CentOS中的shell前端软件包管理器。

基于rpm包管理，能够从指定的服务器（yum源）自动下载rpm包并安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包，无需繁琐的一次次下载安装。

**yum源配置**

![image-20251013103125031](/Users/matt/Desktop/Learning/learning_notes/notes/images/yum.png)

yum源配置文件所在路径： `/etc/yum.repos.d`

Ubuntu中apt的配置文件路径：`/etc/apt/`

| **文件 / 目录**        | **作用**                   | **说明**                                                     |
| ---------------------- | -------------------------- | ------------------------------------------------------------ |
| **apt.conf.d/**        | APT 主配置目录             | 存放 apt 的配置碎片，比如缓存路径、代理、自动更新设置等。系统默认按文件名顺序加载。可在这里新建文件修改行为，比如 /etc/apt/apt.conf.d/99proxy 设置代理。 |
| **auth.conf.d/**       | 认证信息目录               | 用于存放访问私有仓库的认证信息，比如 GitHub Packages、私有 APT 源的用户名/密码。 |
| **keyrings/**          | GPG 密钥存放目录（新版本） | 从 Ubuntu 22.04 开始，APT 的签名密钥文件改放在这里（取代旧的 /etc/apt/trusted.gpg.d/）。每个源的 .gpg 密钥单独存放，方便管理和更新。 |
| **preferences.d/**     | 包优先级配置               | 控制软件包版本的选择（APT Pinning）。例如：强制使用某源的特定版本。 |
| **preferences.d.save** | 备份文件                   | 可能是系统升级时的自动备份文件，可忽略。                     |
| **sources.list**       | 主软件源列表               | 定义 APT 默认使用的仓库地址（比如官方 Ubuntu 源）。          |
| **sources.list.d/**    | 附加软件源目录             | 存放其他仓库源文件，如 Docker、Node.js、Google Chrome 的 .list 文件。每个源单独一个文件。 |
| **trusted.gpg.d/**     | GPG 密钥目录（旧版）       | 存放用于验证软件源签名的密钥文件（.gpg 格式）。              |

**配置阿里yum源**

使用阿里源代替系统默认的yum源

```bash
# 1. 备份默认的yum源
cd /etc/yum.repos.d
cp CentOS-Base.repo CentOS-Base.repo.bak

# 2. 使用wget下载阿里云的镜像文件
wget -O /etc/yum.repos.d/CentOS-Base.repo 镜像地址
-O：指定文件的下载名称和地址

# 3. 清理yum缓存
yum clear all

# 4. 重新建立新的缓存（让新yum源生效）
yum makecache
```

Ubuntu中对应操作
```bash
# 1. 备份
cd /etc/apt/
sudo cp sources.list sources.list.bak

# 2. 编辑 /etc/apt/sources.list 文件：
# 将内容替换为（以 Ubuntu 24.04 “noble” 为例 👇）：
sudo vim /etc/apt/sources.list
deb https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiverse

# 3. 清理 apt 缓存
sudo apt clean
sudo apt autoremove

# 4. 重新建立新的缓存
sudo apt update
```

**yum命令详解**

1. 搜索要安装的软件

```bash
# yum search 软件名称的关键词
yum search vim
yum search firefox
```

Ubuntu对应命令

```bash
apt search 关键字
```

| **功能**           | **CentOS (Yum/DNF)** | **Ubuntu (APT)**        |
| ------------------ | -------------------- | ----------------------- |
| 搜索软件包         | yum search <关键字>  | apt search <关键字>     |
| 查看软件包详细信息 | yum info <软件名>    | apt show <软件名>       |
| 安装软件包         | yum install <软件名> | apt install <软件名>    |
| 删除软件包         | yum remove <软件名>  | apt remove <软件名>     |
| 列出所有包         | yum list all         | apt list --all-versions |
| 更新软件           | yum update <软件名>  | apt update <软件名>     |

2. 使用yum安装软件

```bash
# yun install 软件名称关键词 [选项]
选项
-y：yes缩写，确认安装，不提示
yum install vim -y
```

3. 使用yum卸载软件

```bash
# yum remove 软件名称关键词 [选项]
选项
-y：yes缩写，确认卸载，不提示
```

4. 使用yum更新软件

```bash
# yum update 软件名臣关键词 [选项]
选项
-y：yes缩写，确认更新，不提示
```

### LAMP概述

**什么LAMP**

LAMP：Linux + Apache + MySQL + PHP    LAMP架构（组合）

LNMP：Linux + Nginx + MySQL + PHP      LNPM架构（组合）

LNMPA：Linux + Nginx + MySQL + PHP + Apache     Nginx代理方式

Apache：Apache是世界排名第一的web服务器软件

PHP：一种专门用于web开发的编程语言

MySQL：MySQL是一个关系型数据库管理系统，主要用于永久存储项目数据

**AMP三者之间的关系**

![image-20251013145659704](/Users/matt/Desktop/Learning/learning_notes/notes/images/amp.png)

Apache: 用于接收用户的请求（输入网址-> 返回网页-> 结果）

PHP：登录、注册、加入购物车、下单、支付等动态功能（有编程语言的支持）

MySQL：永久保存数据，比如在网站上注册的用户名和密码。

**阿里云的注册、ecs的购买**

略过

**部署前的准备**

1. 关闭防火墙

```bash
systemctl stop firewalld
systemctl disable firewalld
```

2. 关闭selinux

SELinux（security-enhanced Linux）是美国国家安全局（NSA）对于强制访问控制的实现，是Linux历史上最杰出的新安全子系统。

在 **Ubuntu** 中，selinux 默认是 **没有安装的**，因为：

**原因：**

- getenforce 是 **SELinux（Security-Enhanced Linux）** 的工具命令；
- Ubuntu 默认 **不启用 SELinux**；
- Ubuntu 使用的是另一种安全机制：**AppArmor**。

获取SELinux的状态

```bash
# CentOS
getenforce

# Ubuntu
aa-status # 输出中可看到哪些 profile 是 enforced（强制） 或 complain（宽容） 模式。

apparmor module is loaded.
153 profiles are loaded.
57 profiles are in enforce mode.
   /snap/snapd/24792/usr/lib/snapd/snap-confine
   /snap/snapd/24792/usr/lib/snapd/snap-confine//mount-namespace-capture-helper
   /snap/snapd/25202/usr/lib/snapd/snap-confine
   /snap/snapd/25202/usr/lib/snapd/snap-confine//mount-namespace-capture-helper
   /usr/bin/evince
```

临时关闭SELinux：重启后SELinux会自动启动

```bash
# CentOS
setenforce 0

# Ubuntu
aa-complain /etc/apparmor.d/usr.sbin.nginx
```

永久关闭SELinux

```bash
# CentOS
vim /etc/selinux/config
SELINUX=disabled

# Ubuntu
sudo systemctl stop apparmor
sudo systemctl disable apparmor
```

3. 检查当前的系统是否安装apache、mysql和php服务

```bash
# CentOS
rpm -qa | grep apache
rpm -qa | grep mysql
rpm -qa | grep php

# Ubuntu
dpkg -l | grep apache
dpkg -l | grep mysql
dpkg -l | grep php
```

> AMP安装指南：在Linux安装AMP时，必须先安装Apache，再安装MySQL，最后安装PHP

**Linux环境值Apache的安装**

Apache: 阿帕奇，Apache基金会。

第一步：安装Apache软件

```bash
# CentOS
yum install httpd -y

# Ubuntu
apt install apache2 -y
```

第二步：配置`etc/httpd/conf/httpd.conf`文件

```bash
# CentOS
vim /etc/httpd/conf/httpd.conf
/ServerName => 搜索
ServerName localhost:80

# Ubuntu
vim /etc/apache2/apache2.conf
# 不过通常更推荐修改 站点配置文件。
vim /etc/apache2/sites-available/000-default.conf
# 在 <VirtualHost *:80> 段中添加或修改这一行：ServerName localhost
<VirtualHost *:80>
    ServerAdmin webmaster@localhost
    ServerName localhost
    DocumentRoot /var/www/html
</VirtualHost>
```

> localhost: 代表本机，对应的ip地址可以使用127.0.0.1或本机的公网ip

第三步：启动httpd服务

```bash
# CentOS
systemctl start httpd

# Ubuntu
systemctl start apache2
```

第四步：把httpd添加到开机启动项中

```bash
# CentOS
systemctl enable httpd

# Ubuntu 
systemctl enable apache2
```

第五步：使用ss或netstat命令查看httpd占用的端口

```bash
# CentOS
netstat -tnlp | grep httpd
ss -naltp | grep httpd

netstat -tnlp | grep apache2
tcp6       0      0 :::80                   :::*                    LISTEN      3846/apache2  
# Ubuntu
netstat -tnlp | grep apache2
ss -naltp | grep apache2

ss -naltp | grep apache2
LISTEN 0      511                *:80              *:*    users:(("apache2",pid=5648,fd=4),("apache2",pid=5647,fd=4),("apache2",pid=3846,fd=4)
```

第六步：在浏览器中输入对应的ip地址访问

**LAMP环境之MySQL安装**

1. 下载MySQL的yum仓库包

```bash
# CentOS 7
# wget https://dev.mysql.com/get/mysql80-community-release-el7-11.noarch.rpm
```

2. 安装仓库包

```bash
rpm -Uvh mysql80-community-release-el7-11.noarch.rpm
```

3. 安装MySQL软件

```bash
yum install mysql-community-server -y
```

> MySQL软件是一个C/S架构的软件，拥有客户端和服务端。mysql-server服务器端（内部也包含了客户端）。community代表社区版（免费开源）。

4. 启动mysql，查看端口占用情况

```bash
systemctl start mysql
netstat -tnlp | grep mysql
```

Ubuntu中mysql安装

```bash
apt install mysql-server -y
netstat -tnlp | grep mysql
tcp        0      0 127.0.0.1:33060         0.0.0.0:*               LISTEN      9238/mysqld         
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      9238/mysqld 
```

**MySQL数据库初始化（重要）**

默认情况下，数据库没有密码，也没有任何数据，必须要初始化。

1. 初始化数据库(设置root密码)

```bash
mysql_secure_installation
# mysql 自带的初始化程序
Securing the MySQL server deployment.

Connecting to MySQL using a blank password.

VALIDATE PASSWORD COMPONENT can be used to test passwords
and improve security. It checks the strength of password
and allows the users to set only those passwords which are
secure enough. Would you like to setup VALIDATE PASSWORD component?

Press y|Y for Yes, any other key for No: y

There are three levels of password validation policy:

LOW    Length >= 8
MEDIUM Length >= 8, numeric, mixed case, and special characters
STRONG Length >= 8, numeric, mixed case, special characters and dictionary                  file

Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0

Skipping password set for root as authentication with auth_socket is used by default.
If you would like to use password authentication instead, this can be done with the "ALTER_USER" command.
See https://dev.mysql.com/doc/refman/8.0/en/alter-user.html#alter-user-password-management for more information.

By default, a MySQL installation has an anonymous user,
allowing anyone to log into MySQL without having to have
a user account created for them. This is intended only for
testing, and to make the installation go a bit smoother.
You should remove them before moving into a production
environment.

Remove anonymous users? (Press y|Y for Yes, any other key for No) : y
Success.


Normally, root should only be allowed to connect from
'localhost'. This ensures that someone cannot guess at
the root password from the network.

Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y
Success.

By default, MySQL comes with a database named 'test' that
anyone can access. This is also intended only for testing,
and should be removed before moving into a production
environment.


Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y
 - Dropping test database...
Success.

 - Removing privileges on test database...
Success.

Reloading the privilege tables will ensure that all changes
made so far will take effect immediately.

Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y
Success.

All done! 
```

在 **Ubuntu / Debian** 系统中，MySQL 默认使用一种叫做 **auth_socket 插件** 的认证方式。

这意味着：

> ✅ 只有系统中的 root 用户（通过 sudo 登录的那个）才能用 socket 登录 MySQL 的 root 用户。
>
> ❌ 不需要密码。
>
> ❌ 不能远程访问。

所以当你执行：

```bash
sudo mysql
```

你是直接用 Linux 的 root 身份登录 MySQL 的 root 账户，而不是用密码。

如果想要修改密码：

也就是让 root 用户通过密码登录（例如给前端、后端或远程工具连接），执行以下步骤：

```bash
# 1. 登录 MySQL
sudo mysql
# 2. 修改认证方式为密码登录
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '12345678';
# 3. 刷新权限
FLUSH PRIVILEGES;
# 4. 验证是否生效
mysql -u root -p
```

2. 把mysql添加到开机启动项

```bash
# CentOS
sudo systemctl enable mysqld
# Ubuntu
sudo systemctl enable mysql
# 查询
systemctl list-unit-files | grep mysql
```

3. 连接msyql测试

```bash
mysql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.01 sec)

mysql> exit
Bye
```

**LAMP环境之PHP的安装**

1. 安装php

```bash
# CentOS
yum install php -y

# Ubuntu
apt install php -y
```

2. 启动php（重启apache软件）

```bash
# CentOS
systemctl restart httpd

# Ubuntu
systemctl restart apache2
```

> 为什么启动php就是重启apache呢？
>
> 因为在LAMP架构中，PHP是以模块的形式追加到内核中，所以启动PHP就相当于重启Apache。

![image-20251013172807178](/Users/matt/Desktop/Learning/learning_notes/notes/images/php01.png)

3. 测试LAMP环境是否可用

第一步：使用cd命令进入/var/www/html

```bash
cd /var/www/html
```

第二步：使用vim命令创建demo.php文件

```bash
vim demo.php
```

第三步：编辑demo.php文件

```bash
# demo.php
<?php
  echo "hello world"
?>
```

编写完成后，保存并退出，然后再浏览器中输入`http:ip/demo.php`

### 部署Discuz！论坛

**Discuz！论坛概述**

Discuz! 论坛是基于PHP+MySQL进行的一套开源的论坛系统。

**下载源代码**

`https://gitee.com/Discuz/DiscuzX`

**上传下载的zip包到服务器**

**使用unzip解压zip包**

```bash
unzip DiscuzX-v3.5.zip
```

**复制discuz中的文件到/var/www/html目录**

```bash
mv DiscuzX-v3.5/upload/* /var/www/html/
```

**打开safari浏览器，输入对应的ip地址**

`http://192.168.101.10`

**安装Discuz**

1. 浏览器输入ip地址后回车，会弹出安装的弹窗，点击同意。
2. 解决目录权限问题

```bash
chmod -R a+w /var/www/html
```

3. 函数依赖问题

![image-20251013200307250](/Users/matt/Desktop/Learning/learning_notes/notes/images/discuz01.png)

```bash
# mysqli_connect()：这是因为安装php时没有安装php-mysqli的扩展的原因导致的
# xml_parser_create(): PHP 扩展缺失 导致的常见问题
# 查看当前php版本
php -v
# PHP 8.3.6 (cli) (built: Jul 14 2025 18:30:55) (NTS)
# php版本为8.3
apt install php8.3-mysql php8.3-xml -y

# 重启apache
systemctl restart apache
```

4. 设置运行环境

选择:**全新安装 Discuz! X 与 UCenter Server**

5. 设置mysql数据库的相关信息

![image-20251013201544020](/Users/matt/Desktop/Learning/learning_notes/notes/images/discuz02.png)

![image-20251013201636951](/Users/matt/Desktop/Learning/learning_notes/notes/images/discuz03.png)

6. 安装完成，访问论坛站点

![image-20251013201819877](/Users/matt/Desktop/Learning/learning_notes/notes/images/discuz04.png)



### 域名与解析



















